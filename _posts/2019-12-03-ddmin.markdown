---
published: true
title: Delta Debugging
layout: post
comments: true
tags: reducing
categories: post
---

## Contents
{:.no_toc}

1. TOC
{:toc}

<script src="/resources/js/graphviz/index.min.js"></script>
<script>
// From https://github.com/hpcc-systems/hpcc-js-wasm
// Hosted for teaching.
var hpccWasm = window["@hpcc-js/wasm"];
function display_dot(dot_txt, div) {
    hpccWasm.graphviz.layout(dot_txt, "svg", "dot").then(svg => {
        div.innerHTML = svg;
    });
}
window.display_dot = display_dot
// from js import display_dot
</script>

<script src="/resources/pyodide/full/3.9/pyodide.js"></script>
<link rel="stylesheet" type="text/css" media="all" href="/resources/skulpt/css/codemirror.css">
<link rel="stylesheet" type="text/css" media="all" href="/resources/skulpt/css/solarized.css">
<link rel="stylesheet" type="text/css" media="all" href="/resources/skulpt/css/env/editor.css">

<script src="/resources/skulpt/js/codemirrorepl.js" type="text/javascript"></script>
<script src="/resources/skulpt/js/python.js" type="text/javascript"></script>
<script src="/resources/pyodide/js/env/editor.js" type="text/javascript"></script>

**Important:** [Pyodide](https://pyodide.readthedocs.io/en/latest/) takes time to initialize.
Initialization completion is indicated by a red border around *Run all* button.
<form name='python_run_form'>
<button type="button" name="python_run_all">Run all</button>
</form>
Note: This is based on the *ddmin* in [the fuzzingbook](https://www.fuzzingbook.org/html/Reducer.html#Delta-Debugging).
### About Delta Debugging

Delta Debugging is a method to reduce failure inducing inputs to their
smallest required size that still induces the same failure. It was
first formally introduced in the paper
[*Simplifying and Isolating Failure-Inducing Input*](https://www.st.cs.uni-saarland.de/papers/tse2002/tse2002.pdf)
by Zeller and Hildebrandt.

The idea of delta debugging is fairly simple. We start by partitioning
the given input string, starting with two partitions -- which have a
given partition length. Then, we check if any of these parts can be
removed without removing the observed failure. If any of these can be
removed, we remove all such parts of the given length. Once no such
parts of the given length can be removed, we reduce the partition
length by two, and do the same process again. This obtains us the
*1-minimal* failure causing string where removal of even a single
character will remove the observed failure.

Given a causal function as below,

<!--
############
def test(s):
    v = re.match("<SELECT.*>", s)
    print("%s  %s %d" % (('+' if v else '.'),  s, len(s)))
    return v

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def test(s):
    v = re.match(&quot;&lt;SELECT.*&gt;&quot;, s)
    print(&quot;%s  %s %d&quot; % ((&#x27;+&#x27; if v else &#x27;.&#x27;),  s, len(s)))
    return v
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
Here is an example run:

```shell
$ python ddmin.py '<SELECT NAME="priority" MULTIPLE SIZE=7>'
.  ty" MULTIPLE SIZE=7> 20
.  <SELECT NAME="priori 20
.  ME="priority" MULTIPLE SIZE=7> 30
+  <SELECT NAty" MULTIPLE SIZE=7> 30
+  <SELECT NALE SIZE=7> 20
.  <SELECT NA 10
.  CT NALE SIZE=7> 15
.  <SELELE SIZE=7> 15
+  <SELECT NAZE=7> 15
.  <SELECT NA 10
.  ELECT NAZE=7> 13
.  <SECT NAZE=7> 13
.  <SELT NAZE=7> 13
.  <SELECNAZE=7> 13
+  <SELECT ZE=7> 13
+  <SELECT =7> 11
+  <SELECT > 9
.  <SELECT  8
.  SELECT > 8
.  <ELECT > 8
.  <SLECT > 8
.  <SEECT > 8
.  <SELCT > 8
.  <SELET > 8
.  <SELEC > 8
+  <SELECT> 8
.  <SELECT 7
<SELECT>
```
## Implementation

How do we implement this?

First, the prerequisites:

<!--
############
import random
import string

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
import random
import string
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
### remove_check_each_fragment()
Given a partition length, we want to split the string into
that many partitions, remove each partition one at a time from the
string, and check if for any of them, the `causal()` succeeds. If it
succeeds for any, then we can skip that section of the string.

<!--
############
def remove_check_each_fragment(instr, part_len, causal):
    pre = ''
    for i in range(0, len(instr), part_len):
        removed, remaining = instr[i:i+part_len], instr[i+part_len:]
        if not causal(pre+remaining):
             pre = pre + removed
    return pre

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def remove_check_each_fragment(instr, part_len, causal):
    pre = &#x27;&#x27;
    for i in range(0, len(instr), part_len):
        removed, remaining = instr[i:i+part_len], instr[i+part_len:]
        if not causal(pre+remaining):
             pre = pre + removed
    return pre
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
There is a reason this function is split from the main function unlike in the
original implementation of `ddmin`. The function `remove_check_each_fragment`
obeys the contract that any string returned by it obeys the contract represented
by the `causal` function. This means that any test case that is produced by
`remove_check_each_fragment` will reproduce the specified behavior, and can be
used for other computations. For example, one may use it for evaluating test
reduction slippage, or for finding other reductions.


### ddmin()

The main function. We start by the smallest number of partitions -- 2.
Then, we check by removing each fragment for success. If removing one
fragment succeeds, we change the current string to the string without that
fragment. So, we remove all fragments that can be removed in that partition
size.
If none of the fragments could be removed, then we reduce the partition length
by half.
If the partition cannot be halved again (i.e, the last partition length was
one) or the string has become empty, we stop the iteration.

<!--
############
def ddmin(cur_str, causal_fn):
    part_len = len(cur_str) // 2
    while part_len and cur_str:
        _str = remove_check_each_fragment(cur_str, part_len, causal_fn)
        if _str == cur_str:
            part_len = part_len // 2
        cur_str = _str

    return cur_str

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def ddmin(cur_str, causal_fn):
    part_len = len(cur_str) // 2
    while part_len and cur_str:
        _str = remove_check_each_fragment(cur_str, part_len, causal_fn)
        if _str == cur_str:
            part_len = part_len // 2
        cur_str = _str

    return cur_str
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
The driver.

<!--
############
def test(s):
    print("%s %d" % (s, len(s)))
    return set('()') <= set(s)

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def test(s):
    print(&quot;%s %d&quot; % (s, len(s)))
    return set(&#x27;()&#x27;) &lt;= set(s)
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>


<!--
############
inputstring = ''.join(random.choices(string.digits +
                      string.ascii_letters +
                      string.punctuation, k=1024))
print(inputstring)

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
inputstring = &#x27;&#x27;.join(random.choices(string.digits +
                      string.ascii_letters +
                      string.punctuation, k=1024))
print(inputstring)
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>


<!--
############
assert test(inputstring)
solution = ddmin(inputstring, test)
print(solution)

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
assert test(inputstring)
solution = ddmin(inputstring, test)
print(solution)
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
The nice thing is that, if you invoke the driver, you can see the reduction in
input length in action. Note that our driver is essentially a best case
scenario. In the worst case, the complexity is $$O(n^2)$$. The worst case is
when tests can result in _unresolved_ status, and the last change always fails.

## Recursive

That was of course illuminating. However, is that the only way to implement this?
*delta-debug* at its heart, is a divide and conquer algorithm. Can we implement it
recursively? This is the direct translation of ddmin from the paper's
formalization, which is recursive.

<!--
############
def ddrmin(cur_str, causal_fn, n=2):
    if len(cur_str) == 1:
        return cur_str

    chunk = len(cur_str) // n
    split_idxs = [i for i in range(0, len(cur_str), chunk)]

    # Try complements
    for index in split_idxs:
        complement = cur_str[:index] + cur_str[index + chunk:]  # Remove it
        if causal_fn(complement):
            return ddrmin(complement, causal_fn, 2)  # Reset n to 2

    # Try subsets
    for index in split_idxs:
        s = cur_str[index:index+chunk]
        if causal_fn(s):
            return ddrmin(s, causal_fn, 2)  # Reset n to 2

    # Increase granularity
    if n < len(cur_str):
        return ddrmin(cur_str, causal_fn, min(2 * n, len(cur_str)))

    return cur_str

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def ddrmin(cur_str, causal_fn, n=2):
    if len(cur_str) == 1:
        return cur_str

    chunk = len(cur_str) // n
    split_idxs = [i for i in range(0, len(cur_str), chunk)]

    # Try complements
    for index in split_idxs:
        complement = cur_str[:index] + cur_str[index + chunk:]  # Remove it
        if causal_fn(complement):
            return ddrmin(complement, causal_fn, 2)  # Reset n to 2

    # Try subsets
    for index in split_idxs:
        s = cur_str[index:index+chunk]
        if causal_fn(s):
            return ddrmin(s, causal_fn, 2)  # Reset n to 2

    # Increase granularity
    if n &lt; len(cur_str):
        return ddrmin(cur_str, causal_fn, min(2 * n, len(cur_str)))

    return cur_str
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
## Recursive2
But, is all that work necessary?
The basic idea is that given a string, we can split it into parts, and check if either
part reproduces the failure. If either one does, then call `ddrmin()` on the part that
reproduced the failure.

If neither one did, then it means that there is some part in the first partition that
is required for failure, and there is some part in the second partition too that is required
for failure. All that we need to do now, is to isolate these parts. How should we do that?

Call `ddrmin()` but with an updated check. For example, for the first part, rather than
checking if some portion of the first part alone produces the failure, check if some part of
first, when combined with the second will cause the failure.

All we have left to do, is to define the base case. In our case, a character of length one
can not be partitioned to strictly smaller parts. Further, we already know that any string
passed into `ddrmin()` was required for reproducing the failure. So, we do not have to
worry about empty string. Hence, we can return it as is.

Here is the implementation.
Note: This is the algorithm(1) from the paper [^zeller1999] with minor modifications.

### ddrmin()

<!--
############
def ddrmin(cur_str, causal_fn, pre='', post=''):
    if len(cur_str) == 1: return cur_str

    part_i = len(cur_str) // 2
    string1, string2 = cur_str[:part_i], cur_str[part_i:]
    if causal_fn(pre + string1 + post):
        return ddrmin(string1, causal_fn, pre, post)
    elif causal_fn(pre + string2 + post):
        return ddrmin(string2, causal_fn, pre, post)
    s1 = ddrmin(string1, causal_fn, pre, string2 + post)
    s2 = ddrmin(string2, causal_fn, pre + s1, post)
    return s1 + s2

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
def ddrmin(cur_str, causal_fn, pre=&#x27;&#x27;, post=&#x27;&#x27;):
    if len(cur_str) == 1: return cur_str

    part_i = len(cur_str) // 2
    string1, string2 = cur_str[:part_i], cur_str[part_i:]
    if causal_fn(pre + string1 + post):
        return ddrmin(string1, causal_fn, pre, post)
    elif causal_fn(pre + string2 + post):
        return ddrmin(string2, causal_fn, pre, post)
    s1 = ddrmin(string1, causal_fn, pre, string2 + post)
    s2 = ddrmin(string2, causal_fn, pre + s1, post)
    return s1 + s2
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
Let us redefine our ddmin

<!--
############
ddmin = ddrmin

############
-->
<form name='python_run_form'>
<textarea cols="40" rows="4" name='python_edit'>
ddmin = ddrmin
</textarea><br />
<pre class='Output' name='python_output'></pre>
<div name='python_canvas'></div>
</form>
Given that it is a recursive procedure, one may worry about stack exhaustion, especially
in languages such as Python which allocates just the bare minimum stack by default. The
nice thing here is that, since we split the string by half again and again, the maximum
stack size required is $$log(N)$$ of the input size. So there is no danger of exhaustion.

[^zeller1999]: Yesterday, my program worked.Today, it does not. Why? Zeller, 1999.


<form name='python_run_form'>
<button type="button" name="python_run_all">Run all</button>
</form>

## Artifacts

The runnable Python source for this notebook is available [here](https://github.com/rahulgopinath/rahulgopinath.github.io/blob/master/notebooks/2019-12-03-ddmin.py).


