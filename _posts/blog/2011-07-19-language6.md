---
layout: post
category : blog
tagline: "."
tags : [blog haskell language]
e: Construcing a Language - Adding environments
---

The sixth installment
Task1 : Implement { and } discussed in class.
Task2 : Implement an array marker, '('
What the array marker does is that it allows us to create active arrays.
You start by pushing the opening array marker '(' on the stack, and do
all the stuff, then, when you push the ending array marker ')', it
collects every thing in the stack and makes that into an array.

for example

~~~
ghci> eval "1 2 ( 3 4 5 dup + swap )"
1 2 [3 10 4]

ghci> eval "1 2 ( 3 4 5 + + )"
1 2 [12]
~~~

Hint. The way to do it is almost exactly like '{' is implemented, except
that we are using the stack rather than env.



~~~
module Main where

import System.Environment 
import System.IO 
import Data.Char
~~~

Parsing code: What it does is that it starts looking at a provided string, and
parses into a nested structure given by the data type "Nest". Our nesting is
provided by square brackets.

~~~
import Text.ParserCombinators.Parsec

type Word = String
type Env = [(String, [Nest])]
type Stack = [Nest]

initlib = unlines[
  "[succ 1 +].",
  "[pred 1 -].",
  "[even? odd? not].",
  "[double dup +].",
  "[half dup odd? [succ 2 /] [2 /] if].",
  "[if* 2 nwrap [!] swap dip i if].",
  "[zero? 0 =?].", 
  "[factorial [zero?] [pop 1] [dup pred factorial *] if*]."
  ]
~~~

Read a line and Parse it, returing the Nest data structure.

~~~
readLine :: String -> Nest
readLine input = case parse parseExpr "nest" input of
    Left err -> error (show err)
    Right q -> q

showStack = unwords . reverse . (map show)

eval :: String -> String
eval str = showStack $ bigStep [] e []
  where  Nested e = readLine (initlib ++ " " ++ str)

evalFile file = do
  str <- readFile file
  return $ eval str

main = do
  fn <- getArgs
  case fn of
      [] -> error "Need file.nst to evaluate."
      (x:xs) -> do res <- evalFile $ fn !! 0
                   putStrLn (show res)
~~~

Parse a number of words or nested structures.

~~~
parseExpr = do
  x <- many parseSingle
  return $ Nested x
~~~

Parse either a single word or a nested []

~~~
parseSingle :: Parser Nest
parseSingle = do
  spaces
  x <- (try parseFloat) <|>
       (try parseInt) <|>
       (try parseNegInt) <|>
       (try parseBool) <|>
       (try parseString) <|>
       (try parseWord) <|>
       (try parseNest)
  spaces
  return x
~~~

Parse a nested structure starting with [ and ending with ]

~~~
parseNest :: Parser Nest
parseNest = do
  char '['
  e <- parseExpr
  char ']'
  return e

parseFloat :: Parser Nest
parseFloat = do
  I i <- parseInt
  char '.'
  I j <- parseInt
  res <- return $ (show i) ++ ['.'] ++ (show j)
  return $ F (read res)

parseNegInt :: Parser Nest
parseNegInt = do
  char '-'
  i <- many1 digit
  return $ I $ -1 * (read i)

parseInt :: Parser Nest
parseInt = do
  i <- many1 digit
  return $ I (read i)
~~~

Parse a simple word without any spaces or nesting between them.

~~~
parseWord :: Parser Nest
parseWord = do
  w <- many1 (noneOf " nrt[]")
  return $ W w

parseBool :: Parser Nest
parseBool = do
  (x:xs) <- string "true" <|> string "false"
  return $ B (read (toUpper x : xs))

parseString :: Parser Nest
parseString = do
  char '''
  s <- many (noneOf "'")
  char '''
  return $ S s
~~~



#### Can you write the BNF notation for this language?

A number is a sequence of digits

~~~
 <digit>   ::= 0..9
 <num>     ::= <digit>
             | <digit><num>

 <letter>  ::= a..z | + | - | * | / | < | > | = | .
~~~

We define char to be either a letter or a number (non white space.)

~~~
 <char>    ::= <letter>
             | <digit>
~~~

So that we can have words like dup2 that includes a number

~~~
 <word>    ::= <letter>
              | <word> <char>
~~~

A nest is either a number or a word or an expression of the form [ .. ]

~~~
 <nest>    ::= <num>
             | <word>
             | [ <nest>* ]
~~~

And ofcourse our expression is just a list of nests

~~~
 <expr>   ::= <nest>*
~~~

#### Can you define the data structure required for a larger abstract syntax?

Currently we have,

~~~
data Nest = W String
          | I Int
          | F Float
          | B Bool
          | S String
          | Nested [Nest]
  deriving (Eq)

instance Show Nest where
  show (W s) = s
  show (S s) = (show s)
  show (I i) = (show i)
  show (F f) = (show f)
  show (B b) = (show b)
  show (Nested b) = "[" ++ (unwords (map show b)) ++ "]"
~~~

This is somewhat limited, We should atleast have a way to store real numbers (Float),
Strings like "hello world", and booleans like true and false. Can you extend our data
to add these things? Once you have done that, can you change the portions commented with
TODO to use these instead? (Hint, you can use (read x) to conver x to any of int, bool
or float from a string)
what does the expression below give you if you execute on ghci after doing the above?
readLine  " 'hello world' 'hi' swap concat "
Remember, we are defining our abstract syntax here. So readLine now prints the abstract
syntax of the line being read.

#### Can you define the bigStep semantics of the given? See below for an example.

~~~
bigStep :: Env -> [Nest] -> Stack -> Stack
~~~

Base case. Nothing on execution stack.

~~~
bigStep _ [] r = r
~~~

BigStep semantics for literals. i.e integers, floats strings and nests evaluate to themselves.

~~~
bigStep env (Nested n: xs) ys = bigStep env xs (Nested n: ys)
bigStep env (I i: xs) ys = bigStep env xs (I i: ys)
~~~

implement the same for Float, Boolean, and String

~~~
bigStep env (F i: xs) ys = bigStep env xs (F i: ys)
bigStep env (B i: xs) ys = bigStep env xs (B i: ys)
bigStep env (S i: xs) ys = bigStep env xs (S i: ys)
~~~

BigStep Semantics for addition.

~~~
bigStep env (W "+": xs) (I i: I j: ys) = bigStep env xs (I (j+i): ys)
bigStep env (W "*": xs) (I i: I j: ys) = bigStep env xs (I (j*i): ys)
bigStep env (W "-": xs) (I i: I j: ys) = bigStep env xs (I (j-i): ys)
bigStep env (W "/": xs) (I i: I j: ys) = bigStep env xs (F ((fromIntegral j)/(fromIntegral i)): ys)
bigStep env (W ">": xs) (I i: I j: ys) = bigStep env xs (B (j > i): ys)
bigStep env (W "<": xs) (I i: I j: ys) = bigStep env xs (B (j < i): ys)

bigStep env (W "=?": xs) (I i: I j: ys) = bigStep env xs (B (j == i): ys)
bigStep env (W "=?": xs) (S i: S j: ys) = bigStep env xs (B (j == i): ys)
bigStep env (W "=?": xs) (B i: B j: ys) = bigStep env xs (B (j == i): ys)
bigStep env (W "=?": xs) (F i: F j: ys) = bigStep env xs (B (j == i): ys)
bigStep env (W "=?": xs) (Nested i: Nested j: ys) = bigStep env xs (B (j == i): ys)

bigStep env (W "odd?": xs) (I i: ys) = bigStep env xs (B (odd i): ys)

bigStep env (W "and": xs) (B a:B b:ys) = bigStep env xs (B (b && a):ys)
bigStep env (W "or": xs) (B a:B b:ys) = bigStep env xs (B (b || a):ys)
bigStep env (W "not": xs) (B a:ys) = bigStep env xs (B (not a):ys)
~~~

implement the same for - : if you have - a b , then the result of (a - b) should be on the stack.
      same for *. Can you implement it for division? (hint, remember to use F Float for result)

implement the same for dup  : duplicate the topmost element.

~~~
bigStep env (W "dup": xs) (y:ys) = bigStep env xs (y:y:ys)
~~~

implement the same for swap : swap the two topmost elements.

~~~
bigStep env (W "swap": xs) (y:y':ys) = bigStep env xs (y':y:ys)
~~~


implement the same for pop : remove the topmost element.

~~~
bigStep env (W "pop": xs) (y:ys) = bigStep env xs ys
~~~

implement cons operator -- a:as in haskell

~~~
bigStep env (W "cons": xs) (Nested y':y:ys) = bigStep env xs (Nested (y:y'):ys)
~~~

inmplement concat operator -- ++ in haskell

~~~
bigStep env (W "concat": xs) (Nested y':Nested y:ys) = bigStep env xs (Nested (y ++ y'):ys)
~~~

implement empty? for a list.

~~~
bigStep env (W "empty?": xs) (Nested y:ys) = bigStep env xs (B (length y == 0):ys)
~~~

Another operator is nwrap that takes an integer and pulls out that many elements in the stack into
a list.

~~~
bigStep env (W "nwrap": xs) (I i:ys) = bigStep env xs ((Nested lst) : rest)
  where lst = take i ys
        rest = drop i ys
~~~

Remember the i combinator?  that is 

~~~
[1 2] i + == 3
[1 2 +] i == 3
~~~

implement the i. - pull out the topmost nesting out of the stack and push it into the execution queue

~~~
bigStep env (W "i":xs) (Nested v:ys) = bigStep env (v ++ xs) ys
~~~

implement ! it executes the statement on the stack non destructively.

~~~
1 2 3 [+ +] ! == 1 2 3 6
1 2 3 [+] ! == 1 2 3 5
~~~

~~~
bigStep env (W "!":xs) ys = bigStep env xs $ (head res):(tail ys)
  where res = bigStep env (W "i":xs) ys
~~~

We also need something called "dip" - an operator that pulls out the last element from the stack,
executes the current list on the remaining stack elements and puts the pulled element back. This is 
useful to provide a temporary place to store values. (see the example of if* to see how it is used.)

~~~
bigStep env (W "dip":xs) (y:ys) = bigStep env xs $ y:lst
  where lst = bigStep env [W "i"] ys
~~~

if then else

~~~
bigStep env (W "if":xs) (Nested v2:Nested v1:B c:ys) = bigStep env (res ++ xs) ys
  where res = if c then v1 else v2
~~~

Implementing definitions.

~~~
bigStep env (W ".":xs) (Nested ((W w):as):ys) = bigStep ((w,as):env) xs ys
~~~

If not built in, look up in the environment.

~~~
bigStep env (W x :xs) ys = bigStep env (def ++ xs) ys
  where def = case lookup x env of
          Nothing -> error ("Definition not found or is not applicable for word  {" ++ x ++ "} with stack " ++ (showStack ys))  
          Just x -> x
~~~


