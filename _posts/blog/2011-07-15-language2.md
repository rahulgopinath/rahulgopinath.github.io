---
layout: post
category : blog
tagline: "."
tags : [blog haskell language]
e: Construcing a Language: Slightly more Parsing
---

### More Parsing

~~~ haskell
module Main where
~~~

Parsing code: What it does is that it starts looking at a provided string, and
parses into a nested structure given by the data type "Nest". Our nesting is
provided by square brackets.

~~~ haskell
import Text.ParserCombinators.Parsec

type Word = String
~~~

Read a line and Parse it, returing the Nest data structure.

~~~
readLine :: String -> IO Nest
readLine input = case parse parseExpr "nest" input of
    Left err -> error (show err)
    Right q -> return q
~~~

Parse a number of words or nested structures.

~~~
parseExpr = do
  x <- many parseSingle
  return $ Nested x
~~~

Parse either a single word or a nested `[]`

~~~
parseSingle :: Parser Nest
parseSingle = do
  spaces
  x <- (try parseFloat) <|>
       (try parseInt) <|>
       (try parseBool) <|>
       (try parseString) <|>
       (try parseWord) <|>
       (try parseNest)
  spaces
  return x
~~~

Parse a nested structure starting with `[` and ending with `]`

~~~
parseNest :: Parser Nest
parseNest = do
  char '['
  e <- parseExpr
  char ']'
  return e

parseFloat :: Parser Nest
parseFloat = do
  I i <- parseInt
  char '.'
  I j <- parseInt
  res <- return $ (show i) ++ ['.'] ++ (show j)
  return $ W res       -- TODO: change W to what you defined for float.

parseInt :: Parser Nest
parseInt = do
  i <- many1 digit
  return $ I (read i)
~~~

Parse a simple word without any spaces or nesting between them.

~~~
parseWord :: Parser Nest
parseWord = do
  w <- many1 (noneOf " nrt[]")
  return $ W w

parseBool :: Parser Nest
parseBool = do
  b <- string "true" <|> string "false"
  return $ W (read b)       -- TODO: change W to what you defined for bool.

parseString :: Parser Nest
parseString = do
  char '''
  s <- many (noneOf "'")
  char '''
  return $ W s       -- TODO: change W to what you defined for string.
~~~



####  Can you write the BNF notation for this language?

* A number is a sequence of digits

~~~
 | <digit>   ::= 0..9
 | <num>     ::= <digit>
 |             | <digit><num>

 | <letter>  ::= a..z | + | - | * | / | < | > | = | .
~~~

We define char to be either a letter or a number (non white space.)

~~~
 | <char>    ::= <letter>
 |             | <digit>
~~~

So that we can have words like `dup2` that includes a number

~~~
 | <word>    ::= <letter>
 |             | <word> <char>
~~~

A nest is either a number or a word or an expression of the form `[ .. ]`

~~~
 | <nest>    ::= <num>
 |             | <word>
 |             | [ <nest>* ]
~~~

And ofcourse our expression is just a list of nests

~~~
 | <expr>   ::= <nest>*
~~~

#### Can you define the data structure required for a larger abstract syntax?
Currently we have,

~~~
data Nest = W Word
          | I Int
          | Nested [Nest]
  deriving (Show)
~~~

This is somewhat limited, We should atleast have a way to store real numbers (Float),
Strings like "hello world", and booleans like true and false. Can you extend our data
to add these things? Once you have done that, can you change the portions commented with
TODO to use these instead? (Hint, you can use (read x) to conver x to any of int, bool
or float from a string)
what does the expression below give you if you execute on ghci after doing the above?
`readLine  " 'hello world' 'hi' swap concat "`
Remember, we are defining our abstract syntax here. So readLine now prints the abstract
syntax of the line being read.

