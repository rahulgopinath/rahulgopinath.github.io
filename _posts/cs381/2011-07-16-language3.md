---
layout: post
category : blog
tagline: "."
tags : [cs381 blog haskell language]
e: Construcing a Language - Bigstep Semantics
---

~~~ haskell
module Main where

import System.Environment 
import System.IO 
import Data.Char
~~~

Parsing code: What it does is that it starts looking at a provided string, and
parses into a nested structure given by the data type "Nest". Our nesting is
provided by square brackets.

~~~ haskell
import Text.ParserCombinators.Parsec

type Word = String
type Env = [(String, [Nest])]
type Stack = [Nest]
~~~

Read a line and Parse it, returing the Nest data structure.

~~~ haskell
readLine :: String -> Nest
readLine input = case parse parseExpr "nest" input of
    Left err -> error (show err)
    Right q -> q

eval :: String -> [Nest]
eval str = bigStep [] e []
  where  Nested e = readLine str

evalFile file = do
  str <- readFile file
  return $ eval str

main = do
  fn <- getArgs
  case fn of
      [] -> error "Need file.nst to evaluate."
      (x:xs) -> do res <- evalFile $ fn !! 0
                   putStrLn (show res)
~~~

Parse a number of words or nested structures.

~~~ haskell
parseExpr = do
  x <- many parseSingle
  return $ Nested x
~~~

Parse either a single word or a nested []

~~~
parseSingle :: Parser Nest
parseSingle = do
  spaces
  x <- (try parseFloat) <|>
       (try parseInt) <|>
       (try parseBool) <|>
       (try parseString) <|>
       (try parseWord) <|>
       (try parseNest)
  spaces
  return x
~~~

Parse a nested structure starting with [ and ending with ]

~~~
parseNest :: Parser Nest
parseNest = do
  char '['
  e <- parseExpr
  char ']'
  return e

parseFloat :: Parser Nest
parseFloat = do
  I i <- parseInt
  char '.'
  I j <- parseInt
  res <- return $ (show i) ++ ['.'] ++ (show j)
  return $ F (read res)

parseInt :: Parser Nest
parseInt = do
  i <- many1 digit
  return $ I (read i)
~~~

Parse a simple word without any spaces or nesting between them.

~~~
parseWord :: Parser Nest
parseWord = do
  w <- many1 (noneOf " nrt[]")
  return $ W w

parseBool :: Parser Nest
parseBool = do
  (x:xs) <- string "true" <|> string "false"
  return $ B (read (toUpper x : xs))

parseString :: Parser Nest
parseString = do
  char '''
  s <- many (noneOf "'")
  char '''
  return $ S s
~~~



#### Can you write the BNF notation for this language?

A number is a sequence of digits

~~~

 <digit>   ::= 0..9
 <num>     ::= <digit>
             | <digit><num>

 <letter>  ::= a..z | + | - | * | / | < | > | = | .
~~~

We define char to be either a letter or a number (non white space.)

~~~
 <char>    ::= <letter>
             | <digit>
~~~

So that we can have words like dup2 that includes a number

~~~
 <word>    ::= <letter>
              | <word> <char>
~~~

A nest is either a number or a word or an expression of the form [ .. ]

~~~
 <nest>    ::= <num>
             | <word>
             | [ <nest>* ]
~~~

And ofcourse our expression is just a list of nests

~~~
 <expr>   ::= <nest>*
~~~

#### Can you define the data structure required for a larger abstract syntax?

Currently we have,

~~~
data Nest = W String
          | I Int
          | F Float
          | B Bool
          | S String
          | Nested [Nest]
  deriving (Show)
~~~

This is somewhat limited, We should atleast have a way to store real numbers (Float),
Strings like "hello world", and booleans like true and false. Can you extend our data
to add these things? Once you have done that, can you change the portions commented with
TODO to use these instead? (Hint, you can use (read x) to conver x to any of int, bool
or float from a string)
what does the expression below give you if you execute on ghci after doing the above?

~~~ haskell
readLine  " 'hello world' 'hi' swap concat "
~~~

Remember, we are defining our abstract syntax here. So readLine now prints the abstract
syntax of the line being read.

#### Can you define the bigStep semantics of the given? See below for an example.

~~~ haskell
bigStep :: Env -> [Nest] -> Stack -> [Nest]
~~~

Base case. Nothing on execution stack.

~~~ haskell
bigStep _ [] r = r
~~~

BigStep semantics for literals. i.e integers, floats strings and nests evaluate to themselves.

~~~ haskell
bigStep env (Nested n: xs) ys = bigStep env xs (Nested n: ys)
bigStep env (I i: xs) ys = bigStep env xs (I i: ys)
~~~

TODO: implement the same for Float, Boolean, and String

BigStep Semantics for addition.

~~~ haskell
bigStep env (W "+": xs) (I i: I j: ys) = bigStep env xs (I (i+j): ys)
~~~

TODO: implement the same for - : if you have - a b , then the result of (a - b) should be on the stack.
      same for *. Can you implement it for division? (hint, remember to use F Float for result)

TODO: implement the same for dup  : duplicate the topmost element.

TODO: implement the same for swap : swap the two topmost elements.

TODO: implement the same for pop : remove the topmost element.

Remember the i combinator? that is 

~~~
[1 2] i + == 3
[1 2 +] i == 3
~~~

TODO: implement the i. - pull out the topmost nesting out of the stack and push it into the execution queue


Implementing definitions.

~~~ haskell
bigStep env (W ".":xs) (Nested ((W w):as):ys) = bigStep ((w,as):env) xs ys

bigStep env (W x :xs) ys = bigStep env (def ++ xs) ys
  where Just def = lookup x env
~~~

Final case Nothing else matches.

~~~ haskell
bigStep _ x res = res
~~~

