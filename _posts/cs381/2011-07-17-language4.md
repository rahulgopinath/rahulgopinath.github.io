---
layout: post
category : blog
tagline: "."
tags : [blog haskell language cs381]
e: Construcing a Language - More Semantics
---

~~~ haskell
module Main where

import System.Environment 
import System.IO 
import Data.Char
~~~

Parsing code: What it does is that it starts looking at a provided string, and
parses into a nested structure given by the data type "Nest". Our nesting is
provided by square brackets.

~~~ haskell
import Text.ParserCombinators.Parsec

type Word = String
type Env = [(String, [Nest])]
type Stack = [Nest]
~~~

TODO, expand the initlib.

~~~ haskell
initlib = "[succ 1 +]. [even? odd? not]. [double dup +]. [half dup odd? [succ 2 /] [2 /] if]."
~~~

Read a line and Parse it, returing the Nest data structure.

~~~ haskell
readLine :: String -> Nest
readLine input = case parse parseExpr "nest" input of
    Left err -> error (show err)
    Right q -> q

eval :: String -> [Nest]
eval str = bigStep [] e []
  where  Nested e = readLine (initlib ++ " " ++ str)

evalFile file = do
  str <- readFile file
  return $ eval str

main = do
  fn <- getArgs
  case fn of
      [] -> error "Need file.nst to evaluate."
      (x:xs) -> do res <- evalFile $ fn !! 0
                   putStrLn (show res)
~~~

Parse a number of words or nested structures.

~~~ haskell
parseExpr = do
  x <- many parseSingle
  return $ Nested x
~~~

Parse either a single word or a nested []

~~~ haskell
parseSingle :: Parser Nest
parseSingle = do
  spaces
  x <- (try parseFloat) <|>
       (try parseInt) <|>
       (try parseBool) <|>
       (try parseString) <|>
       (try parseWord) <|>
       (try parseNest)
  spaces
  return x
~~~

Parse a nested structure starting with [ and ending with ]

~~~ haskell
parseNest :: Parser Nest
parseNest = do
  char '['
  e <- parseExpr
  char ']'
  return e

parseFloat :: Parser Nest
parseFloat = do
  I i <- parseInt
  char '.'
  I j <- parseInt
  res <- return $ (show i) ++ ['.'] ++ (show j)
  return $ F (read res)

parseInt :: Parser Nest
parseInt = do
  i <- many1 digit
  return $ I (read i)
~~~

Parse a simple word without any spaces or nesting between them.

~~~ haskell
parseWord :: Parser Nest
parseWord = do
  w <- many1 (noneOf " nrt[]")
  return $ W w

parseBool :: Parser Nest
parseBool = do
  (x:xs) <- string "true" <|> string "false"
  return $ B (read (toUpper x : xs))

parseString :: Parser Nest
parseString = do
  char '''
  s <- many (noneOf "'")
  char '''
  return $ S s
~~~



#### Can you write the BNF notation for this language?

A number is a sequence of digits

~~~
 <digit>   ::= 0..9
 <num>     ::= <digit>
             | <digit><num>

 <letter>  ::= a..z | + | - | * | / | < | > | = | .
~~~

We define char to be either a letter or a number (non white space.)

~~~
 <char>    ::= <letter>
             | <digit>
~~~

So that we can have words like dup2 that includes a number

~~~
 <word>    ::= <letter>
              | <word> <char>
~~~

A nest is either a number or a word or an expression of the form [ .. ]

~~~
 <nest>    ::= <num>
             | <word>
             | [ <nest>* ]
~~~

And of course our expression is just a list of nests

~~~
 <expr>   ::= <nest>*
~~~

#### Can you define the data structure required for a larger abstract syntax?

Currently we have,

~~~ haskell
data Nest = W String
          | I Int
          | F Float
          | B Bool
          | S String
          | Nested [Nest]
  deriving (Show, Eq)
~~~

This is somewhat limited, We should at least have a way to store real numbers (Float),
Strings like "hello world", and booleans like true and false. Can you extend our data
to add these things? Once you have done that, can you change the portions commented with
TODO to use these instead? (Hint, you can use (read x) to convert x to any of int, bool
or float from a string)
what does the expression below give you if you execute on ghci after doing the above?
readLine  " 'hello world' 'hi' swap concat "
Remember, we are defining our abstract syntax here. So readLine now prints the abstract
syntax of the line being read.

####  Can you define the bigStep semantics of the given? See below for an example.

~~~ haskell
bigStep :: Env -> [Nest] -> Stack -> [Nest]
~~~

Base case. Nothing on execution stack.

~~~ haskell
bigStep _ [] r = r
~~~

BigStep semantics for literals. i.e integers, floats strings and nests evaluate to themselves.

~~~ haskell
bigStep env (Nested n: xs) ys = bigStep env xs (Nested n: ys)
bigStep env (I i: xs) ys = bigStep env xs (I i: ys)
~~~

implement the same for Float, Boolean, and String

BigStep Semantics for addition.

~~~ haskell
bigStep env (W "+": xs) (I i: I j: ys) = bigStep env xs (I (i+j): ys)
bigStep env (W "*": xs) (I i: I j: ys) = bigStep env xs (I (i*j): ys)
bigStep env (W "-": xs) (I i: I j: ys) = bigStep env xs (I (i-j): ys)
bigStep env (W "/": xs) (I i: I j: ys) = bigStep env xs (F ((fromIntegral i)/(fromIntegral j)): ys)
bigStep env (W ">": xs) (I i: I j: ys) = bigStep env xs (B (i > j): ys)
bigStep env (W "<": xs) (I i: I j: ys) = bigStep env xs (B (i < j): ys)

bigStep env (W "=?": xs) (I i: I j: ys) = bigStep env xs (B (i == j): ys)
bigStep env (W "=?": xs) (S i: S j: ys) = bigStep env xs (B (i == j): ys)
bigStep env (W "=?": xs) (B i: B j: ys) = bigStep env xs (B (i == j): ys)
bigStep env (W "=?": xs) (F i: F j: ys) = bigStep env xs (B (i == j): ys)
bigStep env (W "=?": xs) (Nested i: Nested j: ys) = bigStep env xs (B (i == j): ys)

bigStep env (W "odd?": xs) (I i: ys) = bigStep env xs (B (odd i): ys)

bigStep env (W "and": xs) (B a:B b:ys) = bigStep env xs (B (a && b):ys)
bigStep env (W "or": xs) (B a:B b:ys) = bigStep env xs (B (a || b):ys)
bigStep env (W "not": xs) (B a:ys) = bigStep env xs (B (not a):ys)
~~~

implement the same for - : if you have - a b , then the result of (a - b) should be on the stack.
      same for *. Can you implement it for division? (hint, remember to use F Float for result)

implement the same for dup  : duplicate the topmost element.

~~~ haskell
bigStep env (W "dup": xs) (y:ys) = bigStep env xs (y:y:ys)
~~~

implement the same for swap : swap the two topmost elements.

~~~ haskell
bigStep env (W "swap": xs) (y:y':ys) = bigStep env xs (y':y:ys)
~~~


implement the same for pop : remove the topmost element.

~~~ haskell
bigStep env (W "pop": xs) (y:ys) = bigStep env xs ys
~~~

implement cons operator -- a:as in haskell

~~~ haskell
bigStep env (W "cons": xs) (y:Nested y':ys) = bigStep env xs (Nested (y:y'):ys)
~~~

implement concat operator -- ++ in haskell

~~~ haskell
bigStep env (W "concat": xs) (Nested y:Nested y':ys) = bigStep env xs (Nested (y ++ y'):ys)
~~~

implement empty? for a list.

~~~ haskell
bigStep env (W "empty?": xs) (Nested y:ys) = bigStep env xs (B (length y == 0):ys)
~~~

Remember the i combinator? that is 

~~~
[1 2] i + == 3
[1 2 +] i == 3
~~~

implement the i. - pull out the topmost nesting out of the stack and push it into the execution queue

if then else

~~~ haskell
bigStep env (W "if":xs) (Nested v2:Nested v1:B c:ys) = bigStep env (res ++ xs) ys
  where res = if c then v1 else v2
~~~

Implementing definitions.

~~~ haskell
bigStep env (W ".":xs) (Nested ((W w):as):ys) = bigStep ((w,as):env) xs ys

bigStep env (W x :xs) ys = bigStep env (def ++ xs) ys
  where Just def = lookup x env
~~~

Final case Nothing else matches.

~~~ haskell
bigStep _ x res = res
~~~

