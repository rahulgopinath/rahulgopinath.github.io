---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
e: Scripting with servlets [groovy - using jsr223]  - part VI  (SJS WebServer 7.0)
---
{% raw %}
<div class="entry" id="scripting_with_servlets_groovy_using">

	<h3 class="entry-title">
			Scripting with servlets [groovy - using jsr223]  - part VI  (SJS WebServer 7.0)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Jan 19, 2007</a>
</h4>

    <div class="entry-body">
                                        	<p>Scripting with servlets [using groovy]  This time using the JDK6 and JSR223 Scripting interface</p>
<h3>About the language<br>
</h3>
<p><a title="groovy language home" href="http://groovy.codehaus.org/">groovy</a> is a language much like ruby, except that it's only implementation is over jvm. Its claim to<br>fame is that it integrates tightly with the jvm and the java libraries. (It does not provide any libraries<br>other than what the java itself provides in its standard libraries). However the language itself is quite<br>powerful and supports most of the higher order programming constructs.</p>
<p>(From a moderate hight, the languages like Groovy, Ruby, Javascript, Jython, Sleep all look<br>very similar. You can take what you have learned in one language and expect almost similar tools and<br>syntactical constructs to be available in the other languages too.  If you are interested in languages that<br>really have a very different look and feel, go for either Functional languages -- like Haskell  or for things<br>really different, go for Concatenative languages like <a title="Joy wiki page." href="http://en.wikipedia.org/wiki/Joy_%28programming_language%29">Joy</a>. Unfortunately for us while Haskell has a jvm<br>implementation called <a title="Jaskell" href="http://jaskell.codehaus.org/">Jaskell</a>, The language Joy does not seem to have one. Some others like <a title="factor home." href="http://factorcode.org/">Factor</a><br>did have a jvm implementation but it seems to have moved to native land now.)<br></p>
<h4>Existing Implementations</h4>
<p>Groovy has <a href="http://groovy.codehaus.org/Groovlets" title="groovlets">groovlets</a><br></p>
<p> </p>
<p>In this entry, the discussion is on creating a generic JSR223 compatible servlet that is able to load any<br>scripting api - (jsr223) aware language. To that end Our servlet will either try to figure out the language<br>used from the scripting language handler extension, or will rely on the user supplying a 'language' as an<br>initialization parameter. </p>
<p>We will try to make use of the '<b>Invocable' </b>interface if it is provided by the language implementation<br>to invoke the individual method handlers. However if the language does not provide the Invocable<br>interface will fall back to just evaluating the scripts with relevant variables bound to the context.</p>
<p>One more detail here is that, unlike the other entries, Closures are not used for binding the variables<br>instead, We evaluate the script handler first with the 'httpservlet' variable bound to instance of our<br>java servlet, and let it define the function names that can be called later as the entries in our symbol table.<br></p>
<p>The printEngines() method is provided for debugging support. In case the you find that the scripts does not<br>evaluate, call the printEngines() and monitor the stdout. Perhaps the engine is not getting registered properly.</p>
<p> You can make use of the JSR223Servlet implemented here with any of the other languages that support the<br>java scripting API. The only need is to implement the servlet handler part in the language of your choice and<br>make sure that you redirect the requests to the servlet initialized with the correct 'language' parameter.<br></p>
<h3>External Components<br>
</h3>
<p>We make use of the Groovy Scripting libraries implemented by <a href="http://blogs.sun.com/sundararajan/" title="Sundararajan's blog.">Sundararajan</a> and Mike available <a href="https://scripting.dev.java.net/" title="scripting libraries for java">here</a> <br>They have quite a few languages already made aware of the scripting interface now.<br> </p>
<h3>JSR223Servlet<br>
</h3>
<p>The ScriptServlet developed in the previous <a title="Scripting servlets with Sun Java System WebServer 7.0" target="_blank" href="../../blue/entry/scripting_with_servlets_sun_java">entry</a> is used here as the parent class. <br> <br></p>
<table width="675" height="88" cellspacing="1" cellpadding="1" border="1" align="center"><tbody><tr><td style="width: 100%;">
<p><font size="2" color="#8e2020">package com.sun.servlet;<br><br>import java.io.\*;<br>import java.util.\*;<br>import java.util.regex.\*;<br><br>import javax.servlet.\*;<br>import javax.servlet.http.\*;<br><br>import javax.script.\*;<br></font></p>
<p><font size="2" color="#8e2020">public class JSR223Servlet extends ScriptServlet {<br><br>    private static Pattern FILENAME = Pattern.compile("\^(.\*).([\^.]+)$");<br>    protected ScriptEngineManager _sem = new ScriptEngineManager();<br>    protected ScriptEngine _eng = null;<br><br>    protected ScriptEngine getScriptEngine(String filename)<br>        throws Exception {<br>        // see if the user has some preference?<br>        String lang = getServletConfig().getInitParameter("language");<br>        if (lang != null) {<br>            ScriptEngine se = _sem.getEngineByName(lang);<br>            if (se!= null)<br>                return se;<br>        }<br><br>        // or figure out the engine to use by extension.<br>        Matcher m = FILENAME.matcher(filename);<br>        if (m.matches()) {<br>            String ext = m.group(1);<br>            ScriptEngine se = _sem.getEngineByExtension(ext);<br>            if (se != null)<br>                return se;<br>        }<br><br>        // we failed miserably. :(<br>        throw new Exception("Unable to figure out a script engine to use.");<br>    }<br><br>    public void initialize(String handler, Object code)<br>        throws Exception {<br>        List&lt;ScriptEngineFactory&gt; list = _sem.getEngineFactories(); // seems needed for init.<br>        _eng = getScriptEngine(handler);<br>        // we want to bind the variable httpservlet for initialization rather than<br>        // call a method.<br>        _eng.getContext().setAttribute("httpservlet", this, ScriptContext.ENGINE_SCOPE);<br>        _eng.eval((String)code);<br>    }<br><br>    public void eval(Object fn, HttpServletRequest request, HttpServletResponse response) {<br>        try {<br>            if (_eng instanceof Invocable) {<br>                Invocable inv = (Invocable)_eng;<br>                inv.invokeFunction((String)fn, this, request, response);<br>            } else {<br>                _eng.getContext().setAttribute("httpservlet", this, ScriptContext.ENGINE_SCOPE);<br>                _eng.getContext().setAttribute("request", request, ScriptContext.ENGINE_SCOPE);<br>                _eng.getContext().setAttribute("response", response, ScriptContext.ENGINE_SCOPE);<br>                _eng.eval((String)fn);<br>            }<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }</font></p>
<p><font size="2" color="#8e2020">    public void printEngines() {<br>        List&lt;ScriptEngineFactory&gt; list = _sem.getEngineFactories();<br>        System.out.println("Supported Script Engines");<br>        for (ScriptEngineFactory factory: list) {<br>            // Obtains the full name of the ScriptEngine.<br>            String name = factory.getEngineName();<br>            String version = factory.getEngineVersion();<br>            // Returns the name of the scripting language<br>            // supported by this ScriptEngine<br>            String language = factory.getLanguageName();<br>            String languageVersion = factory.getLanguageVersion();<br>            System.out.printf("Name: %s (%s) : Language: %s v. %s \\n",<br>                    name, version, language, languageVersion);<br>            // Get a list of aliases<br>            List&lt;String&gt; engNames = factory.getNames();<br>            for(String e: engNames) {<br>                System.out.printf("\\tEngine Alias: %s\\n", e);<br>            }<br>        }<br>    }<br><br><br></font></p>
</td></tr></tbody></table>
<p> </p>
<h2>Providing the handler<br>
</h2>
<h3>Jvm Bindings.</h3>
<p>The java objects are accessed in the same way as that of native java in groovy. </p>
<p>ie:  System.out.println("mystring") is written as System.out.println "mystring" - with or with out the parens.<br></p>
<p><b>docroot/WEB-INF/code/groovy.groovy</b><br></p>
<table width="675" height="88" cellspacing="1" cellpadding="1" border="1" align="center"><tbody><tr><td style="width: 100%;"><p><font size="2" color="#8e2020">def do_service (httpservlet, request, response) {<br>    out = response.getWriter()<br>    response.setContentType("text/html")<br>    try {<br>        spath = request.getServletPath()<br>        filename = httpservlet.getServletConfig().getServletContext().getRealPath(spath)<br>        GroovyShell shell = new GroovyShell()<br>        shell.setVariable("request", request);<br>        shell.setVariable("response", response);<br>        shell.setVariable("httpservlet", httpservlet);<br>        out.println shell.evaluate(httpservlet.read(filename).toString(), filename)<br>    } catch (e) {<br>        out.println "&lt;html&gt;&lt;body&gt;&lt;b&gt;Servlet Error ( "+ e.getMessage() + "&lt;/b&gt;&lt;xmp&gt; "<br>        e.printStackTrace(out);<br>        out.println " &lt;/xmp&gt;&lt;/body&gt;&lt;/html&gt;"<br>    }<br>}<br><br>httpservlet.add('get', "do_service")<br>httpservlet.add('post', "do_service")<br><br></font></p></td></tr></tbody></table>
<br><p>Here we are taking another route than the previous entries. We define do_service as a function that takes<br>two arguments, and set the function name in the symbol table (rather than the closures that we used in previous<br>entries or the entire script as was the case in jacl.) Since the httpservlet is defined when the complete<br>script is evaluated the first time, this variable is available for the function too.</p>
<p>The JSR223Servlet takes care of calling the functions with necessary arguments.<br></p>
<p>An example groovy script that can get executed:<br></p>
<p><b>/docroot/hello.groovy</b><br></p>
<table width="675" height="88" cellspacing="1" cellpadding="1" border="1" align="center">
<tbody><tr><td style="width: 100%;"><p><font size="2" color="#8e2020">pre = "&lt;html&gt; &lt;head&gt;&lt;title&gt;abc&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt; Hello at "<br>date = new Date()<br>from = " from "<br>path = request.getServletPath()<br>post = "&lt;/h1&gt;  &lt;/body&gt; &lt;/html&gt;"<br>pre + date + from + path + post<br></font></p></td></tr></tbody>
</table>
<h3>Build  Steps. </h3>
<p>          The complete groovy-webapp can be downloaded <a href="../../blue/resource/servlets/groovy-webapp.tar.gz" title="groovy-webapp">here</a>. Extract the contents to a directory called 'groovy'<br>inside samples in your installation <span style="font-weight: bold;">(</span><b>samples/java/webapps/groovy</b>). It has to be in that directory to make use<br>of the common.xml during ant build.</p>
<h3>Important </h3>
<p>This will work only with JDK6. So make sure that when you install your Sun Java System WebServer, you choose<br>to install it with a pre-installed JDK6 rather than the bundled JDK. Even if you have installed your<br>Sun Java System WebServer with bundled JDK(5), you can still change the <b>java.home</b> variable to point to jdk6<br>in <b>server.xml </b>and use this sample.<br></p>
<p>Your extracted directory will look like this.</p>
<p><font size="2" color="#473f42">|cd groovy<br>|find .<br>./docs<br>./docs/index.html<br>./src<br>./src/build.xml<br>./src/JSR223Servlet.java<br>./src/docroot<br>./src/docroot/WEB-INF<br>./src/docroot/WEB-INF/lib<br>./src/docroot/WEB-INF/lib/groovy-1.0.jar<br>./src/docroot/WEB-INF/lib/groovy-engine.jar<br>./src/docroot/WEB-INF/lib/asm-2.2.jar<br>./src/docroot/WEB-INF/lib/asm-analysis-2.2.jar<br>./src/docroot/WEB-INF/lib/asm-attrs-2.2.jar<br>./src/docroot/WEB-INF/lib/asm-tree-2.2.jar<br>./src/docroot/WEB-INF/lib/asm-util-2.2.jar<br>./src/docroot/WEB-INF/lib/antlr-2.7.5.jar<br>./src/docroot/WEB-INF/lib/LICENSE.TXT<br>./src/docroot/WEB-INF/web.xml<br>./src/docroot/WEB-INF/sun-web.xml<br>./src/docroot/WEB-INF/code<br>./src/docroot/WEB-INF/code/groovy.groovy<br>./src/docroot/index.html<br>./src/docroot/hello.groovy<br>./src/ScriptServlet.java<br>./deploy.tcl<br></font><font size="2" color="#473f42"><br></font> </p>
<p>Please note that there are a number of jar files required for this to work. You need the groovy-engine<br>supplied by https://scripting.dev.java.net/ , the asm antlr and groovy jars supplied by the groovy project.<br></p>
<p>The groovy-webapp.war will be created in the groovy directory when you run ant from inside<br>the src. This war file can be deployed on the webserver using the wadm.<br></p>
<p><font size="2" face="courier new,courier,monospace" color="#0f11ff">wadm </font><font size="2" face="courier new,courier,monospace" color="#0f11ff"> -u admin</font><font size="2" face="courier new,courier,monospace" color="#0f11ff"> -f deploy.tcl</font><br></p>
<p>Once the deployment goes through, you will be able to access the js file using the url</p>
<font size="2" color="#0003ff">http://yourserver:port/groovy/hello.groovy</font>  <p><br></p>
        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: scripting</p>
        <p class="entry-tags">Tags:    
    	    <a href="https://blogs.oracle.com/blue/tags/groovy" rel="tag">groovy</a> 
  	    <a href="https://blogs.oracle.com/blue/tags/jsr223" rel="tag">jsr223</a> 
  	    <a href="https://blogs.oracle.com/blue/tags/jvm" rel="tag">jvm</a> 
  	    <a href="https://blogs.oracle.com/blue/tags/scripting" rel="tag">scripting</a> 
  	    <a href="https://blogs.oracle.com/blue/tags/sevlet" rel="tag">sevlet</a> 
    
 </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/scripting_with_servlets_groovy_using">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
