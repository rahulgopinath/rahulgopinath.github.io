---
layout: post
categories : [sunblog]
tagline: "."
tags : [sunmicrosystems blog sun]
e: wadm - The java nature - scripting in Sun Java System Web Server 7.0 (part V)
---
{% raw %}
<div class="entry" id="the_java_connection_wadm_scripting">

	<h3 class="entry-title">
			wadm - The java nature - scripting in Sun Java System Web Server 7.0 (part V)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 21, 2006</a>
</h4>

    <div class="entry-body">
                                        	
In this section we will try to explore the way java objects are accessible from wadm, and how to get the framework to do our bidding.<br><br><span style="color: rgb(204, 0, 0); font-weight: bold;">Assume the wadm prompt is "|" so that </span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">|puts new</span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">is the wadm command "puts new"</span><br style="color: rgb(204, 0, 0); font-weight: bold;"><h3>Our tools</h3>log into wadm and type<br><br><span style="color: rgb(51, 51, 255);">|java::</span><br><span style="font-style: italic;">ambiguous command name "java::": ::java::autolock ::java::autolock_create_instance ::java::autolock_destroy_instance ::java::bind ::java::call ::java::cast ::java::defineclass ::java::event ::java::field ::java::getinterp ::java::import ::java::info ::java::instanceof ::java::isnull ::java::load ::java::lock ::java::new ::java::null ::java::prop ::java::throw ::java::try ::java::unlock</span><br><br>
<br>These commands are explained <a href="http://tcljava.sourceforge.net/docs/TclJava/contents.html" target="_self">here(external)</a><br><br><h4>Exploring wadm.</h4>
<font size="2"><font size="3"><span style="color: rgb(51, 51, 255);">|java::call java.lang.Thread dumpStack</span></font><br style="font-style: italic;"><span style="font-style: italic;">java.lang.Exception: Stack trace</span><br style="font-style: italic;"><span style="font-style: italic;">        at java.lang.Thread.dumpStack(Thread.java:1158)</span><br style="font-style: italic;"><span style="font-style: italic;">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br style="font-style: italic;"><span style="font-style: italic;">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</span><br style="font-style: italic;"><span style="font-style: italic;">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</span><br style="font-style: italic;"><span style="font-style: italic;">        at java.lang.reflect.Method.invoke(Method.java:585)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.reflect.PkgInvoker.invokeMethod(PkgInvoker.java:125)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.JavaInvoke.call(JavaInvoke.java:263)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.JavaInvoke.callStaticMethod(JavaInvoke.java:176)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.JavaCallCmd.cmdProc(JavaCallCmd.java:74)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.AutoloadStub.cmdProc(Extension.java:144)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Parser.evalObjv(Parser.java:818)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Parser.eval2(Parser.java:1221)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Interp.eval(Interp.java:2222)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Interp.eval(Interp.java:2306)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Interp.recordAndEval(Interp.java:2361)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.ConsoleThread$1.processEvent(JaclShell.java:428)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Notifier.serviceEvent(Notifier.java:444)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.Notifier.doOneEvent(Notifier.java:585)</span><br style="font-style: italic;"><span style="font-style: italic;">        at tcl.lang.JaclShell.invoke(JaclShell.java:193)</span><br style="font-style: italic;"><span style="font-style: italic;">        at com.sun.web.admin.cli.shelladapter.WSadminShell.invokeJaclShell(WSadminShell.java:122)</span><br style="font-style: italic;"><span style="font-style: italic;">        at com.sun.web.admin.cli.shelladapter.WSadminShell.main(WSadminShell.java:104)</span><br></font><br>The <span style="font-weight: bold;">java::call</span> is used to call a static method in the provided class. In this instance we call dumpStack static method in Thread class.<br><br>The last few lines are pretty interesting, It tells us that there is a class called WSadminShell that has invoked the class called JaclShell.<br>Let us explore these two classes.<br><font size="2"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================reflect.tcl==================</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">namespace eval Reflect {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    namespace export get_class for_each_el</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc get_class {cl} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return [java::field $cl class]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc get_name {i} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return [[$i getClass] getName]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc for_each_el {arr cmd} {<br>        set size [$arr length]<br>        set result {}<br>        for {set i 0} {$i &lt; $size} {incr i} {<br>            set e [$arr get $i]<br>            java::lock $e<br>            lappend result [eval $cmd]<br>        }<br>        return $result<br>    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================<br><br></span></font><span style="color: rgb(51, 51, 255);">|source reflect.tcl</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|namespace import Reflect::\*</span><br style="color: rgb(51, 51, 255);"><br>The above commands will import all the methods defined in the reflect namespace to the global.<br><br><span style="color: rgb(51, 51, 255);">|set shelladapter "com.sun.web.admin.cli.shelladapter"</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|set methods [[get_class $shelladapter.WSadminShell] getDeclaredMethods]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|for_each_el $methods {<br>:puts [$e getName]<br>:}<br style="color: rgb(51, 51, 255);"></span><font size="2"><span style="font-style: italic;">main</span><br style="font-style: italic;"><span style="font-style: italic;">invokeJaclShell</span><br style="font-style: italic;"><span style="font-style: italic;">exitIfNotShell</span><br style="font-style: italic;"><span style="font-style: italic;">handleError</span><br style="font-style: italic;"><span style="font-style: italic;">handleError</span><br style="font-style: italic;"><span style="font-style: italic;">handleError</span><br style="font-style: italic;"><span style="font-style: italic;">invokeFramework</span><br style="font-style: italic;"><span style="font-style: italic;">getArg</span><br style="font-style: italic;"><span style="font-style: italic;">getBooleanArg</span><br style="font-style: italic;"><span style="font-style: italic;">getRCFile</span><br style="font-style: italic;"><span style="font-style: italic;">getScriptFileName</span><br style="font-style: italic;"><span style="font-style: italic;">getScriptFilePosition</span><br style="font-style: italic;"><span style="font-style: italic;">invokeConnectCommand</span><br style="font-style: italic;"><span style="font-style: italic;">isConnectOpt</span><br style="font-style: italic;"><span style="font-style: italic;">printVersionAndExit</span><br style="font-style: italic;"><span style="font-style: italic;">printCommandLine</span></font><br><br>As you would have doubtless noticed, the for_each_el is a control structure that we have just defined. It is a powerful faciilty that can be combined<br>with upvar and upeval to emulate almost any kind of features in other languages.<br>
<span style="color: rgb(51, 51, 255);">|for_each_el $methods {puts "[$e getName] - [[$e getParameterTypes] length]"}</span><br><font size="2"><span style="font-style: italic;">main - 1</span><br style="font-style: italic;"><span style="font-style: italic;">invokeJaclShell - 1</span><br style="font-style: italic;"><span style="font-style: italic;">exitIfNotShell - 2</span><br style="font-style: italic;"><span style="font-style: italic;">handleError - 1</span><br style="font-style: italic;"><span style="font-style: italic;">handleError - 1</span><br style="font-style: italic;"><span style="font-style: italic;">handleError - 1</span><br style="font-style: italic;"><span style="font-style: italic;">invokeFramework - 1</span><br style="font-style: italic;"><span style="font-style: italic;">getArg - 3</span><br style="font-style: italic;"><span style="font-style: italic;">getBooleanArg - 3</span><br style="font-style: italic;"><span style="font-style: italic;">getRCFile - 1</span><br style="font-style: italic;"><span style="font-style: italic;">getScriptFileName - 1</span><br style="font-style: italic;"><span style="font-style: italic;">getScriptFilePosition - 1</span><br style="font-style: italic;"><span style="font-style: italic;">invokeConnectCommand - 1</span><br style="font-style: italic;"><span style="font-style: italic;">isConnectOpt - 1</span><br style="font-style: italic;"><span style="font-style: italic;">printVersionAndExit - 0</span><br style="font-style: italic;"><span style="font-style: italic;">printCommandLine - 1</span><br style="font-style: italic;"></font><br>The number of arguments taken by each method.<br>Some of the interesting methods that seem to exist are (purely based on method names)<br><span style="font-style: italic;"><br>invokeJaclShell - 1</span><br style="font-style: italic;">
<span style="font-style: italic;"></span><span style="font-style: italic;"></span><span style="font-style: italic;">invokeFramework - 1</span><br style="font-style: italic;">
<span style="font-style: italic;"></span><span style="font-style: italic;">invokeConnectCommand - 1</span><br style="font-style: italic;">
<span style="font-style: italic;"></span><br>let us try the same with JaclShell, the other interesting class<br><br><span style="color: rgb(51, 51, 255);">|set methods [[get_class tcl.lang.JaclShell] getDeclaredMethods]     </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|for_each_el $methods {puts "[$e getName] - [[$e getParameterTypes] length]"}</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">invoke - 1</span><br style="font-style: italic;"><span style="font-style: italic;">evalRC - 0</span><br style="font-style: italic;"><span style="font-style: italic;">loadWadm - 0</span><br style="font-style: italic;"><span style="font-style: italic;">reader - 0</span><br style="font-style: italic;"><span style="font-style: italic;">fetchCommands - 0</span><br style="font-style: italic;"><span style="font-style: italic;">getTclshrcContent - 0</span><br><br></font>
This is slightly more interesting than the other one.<br>the interesting ones here seems to be <br><span style="font-style: italic;">reader , fetchCommands</span><br><br>Let us take the first one, reader and see what it can tell us<br><span style="color: rgb(51, 51, 255);">|java::info class [java::call tcl.lang.JaclShell reader]</span><br><font size="2"><span style="font-style: italic;">jline.ConsoleReader</span></font><br><br>
<br>This is pretty interesting. More so because it does not belong to either com.sun.xxxx or tcl.lang.xxx which <br>we are expecting. There is a high chance that this is from a different product. Let us ask google.<br>The source for this particular class seems to be accessible <a href="http://sourceware.org/frysk/javadoc/public/jline/ConsoleReader-source.html" target="_self">here</a>.<br><br><a href="http://jline.sourceforge.net/" target="_self">Jline</a> is a package that gives you history, keboard shortcuts and auto completion according to their website.<br>Since the wadm does have all these, it stands to reason that wadm is using jline to implement these.<br><br>
Let us see if we can add a simple completion command to it.<br>looking at the fields of jline.ConsoleReader<br><br><span style="color: rgb(51, 51, 255);">|set f_console [[java::field jline.ConsoleReader class] getDeclaredFields]<br>|java::lock $f_console<br style="color: rgb(51, 51, 255);"></span><span style="color: rgb(51, 51, 255);">|for_each_el $f_console {puts "$i - [$e getName]" }</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">0 - prompt</span><br style="font-style: italic;"><span style="font-style: italic;">1 - useHistory</span><br style="font-style: italic;"><span style="font-style: italic;">2 - CR</span><br style="font-style: italic;"><span style="font-style: italic;">3 - KEYMAP_NAMES</span><br style="font-style: italic;"><span style="font-style: italic;">4 - keybindings</span><br style="font-style: italic;"><span style="font-style: italic;">5 - bellEnabled</span><br style="font-style: italic;"><span style="font-style: italic;">6 - mask</span><br style="font-style: italic;"><span style="font-style: italic;">7 - NULL_MASK</span><br style="font-style: italic;"><span style="font-style: italic;">8 - autoprintThreshhold</span><br style="font-style: italic;"><span style="font-style: italic;">9 - terminal</span><br style="font-style: italic;"><span style="font-style: italic;">10 - completionHandler</span><br style="font-style: italic;"><span style="font-style: italic;">11 - in</span><br style="font-style: italic;"><span style="font-style: italic;">12 - out</span><br style="font-style: italic;"><span style="font-style: italic;">13 - buf</span><br style="font-style: italic;"><span style="font-style: italic;">14 - debugger</span><br style="font-style: italic;"><span style="font-style: italic;">15 - history</span><br style="font-style: italic;"><span style="font-style: italic;">16 - completors</span><br style="font-style: italic;"><span style="font-style: italic;">17 - echoCharacter</span><br style="font-style: italic;"><span style="font-style: italic;">18 - class$jline$ConsoleReader</span><br style="font-style: italic;"></font><br>Of these, according to the jline source, the 'completors' holds the current completion classes.<br>let us define another procedure for easy access of fields<br><font size="2"><span style="color: rgb(204, 0, 0);">========================================<br>    proc get_fields {cl method} {<br>        set arr [[java::field $cl class] $method]<br>        set result {}<br>        foreach {l} [for_each_el $arr {list [$e getName] $e}] {<br>            set result [concat $result $l]<br>        }<br>        return $result<br>    }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">========================================</span></font><br>You can use it as<br><span style="color: rgb(51, 51, 255);">|array set c_fields [get_fields jline.ConsoleReader getDeclaredFields]<br></span><span style="color: rgb(51, 51, 255);">|puts [$c_fields(completors) getName]<br><br><span style="color: rgb(102, 102, 102);">#circumvent private access.</span><br></span><span style="color: rgb(51, 51, 255);">|$c_fields(completors) setAccessible true</span><br><span style="color: rgb(51, 51, 255);">|$c_fields(completors) get [java::call tcl.lang.JaclShell reader]</span><br><span style="color: rgb(51, 51, 255);">|get_name [$c_fields(completors) get [java::call tcl.lang.JaclShell reader]]</span><br><span style="font-style: italic;">java.util.LinkedList</span><br>
<br>so let us go and get one of items out.<br><span style="color: rgb(51, 51, 255);">|[$c_fields(completors) get [java::call tcl.lang.JaclShell reader]] get 0             </span><br style="color: rgb(51, 51, 255);"><span style="font-style: italic;">no accessible method "get" in class java.lang.Object<br><br></span>So we have to cast it to get this things out<span style="font-style: italic;"><br></span><span style="color: rgb(51, 51, 255);">|set completor [[java::cast java.util.List [$c_fields(completors) get [java::call tcl.lang.JaclShell reader]]] get 0]<br></span><span style="font-style: italic;">java0x188<br><br></span>#save for later<span style="font-style: italic;"><br></span><span style="color: rgb(51, 51, 255);">|java::lock $completor<br><br></span><span style="font-style: italic;"></span><span style="color: rgb(51, 51, 255);">|get_name $completor</span><br><span style="font-style: italic;">jline.ArgumentCompletor</span><br><br>So, we got the ArgumentCompletor instance in wadm which is used for completion of arguments. looking at it,<br><span style="color: rgb(51, 51, 255);">|get_fields jline.ArgumentCompletor getDeclaredFields</span><br><span style="font-style: italic;">completors java0x191 delim java0x192 strict java0x193</span><br><br>from <a href="http://sourceware.org/frysk/javadoc/public/jline/ArgumentCompletor-source.html" target="_self">here(external)</a> it looks like completors are the ones we need.<br><br><span style="color: rgb(51, 51, 255);">|array set a_completor [get_fields jline.ArgumentCompletor getDeclaredFields]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|$a_completor(completors) setAccessible true</span><br><span style="font-style: italic;"></span>Using the earlier set variable completor<br><br><span style="color: rgb(51, 51, 255);">|$a_completor(completors) get $completor    </span><br><span style="font-style: italic;">java0x1aa</span><br><span style="color: rgb(51, 51, 255);">|get_name [$a_completor(completors) get $completor]</span><br><span style="font-style: italic;">[Ljline.Completor;</span><br><br>It is an array (the L syntax in java is for array)<br>so we use reflection to get to the array elements.<br><br><span style="color: rgb(51, 51, 255);">|set clist [$a_completor(completors) get $completor] <br><br><span style="color: rgb(0, 0, 0);">#save for later</span><br>|java::lock $clist<br></span><br><span style="color: rgb(51, 51, 255);">|java::call java.lang.reflect.Array get $clist 0</span><br><span style="font-style: italic;">java0x1b1</span><br><br><span style="color: rgb(51, 51, 255);">|get_name [java::call java.lang.reflect.Array get $clist 0]</span><br><span style="font-style: italic;">jline.SimpleCompletor</span><br><br>#save for later<br><span style="color: rgb(51, 51, 255);">
|set s_completor [java::call java.lang.reflect.Array get $clist 0]<br>|java::lock $s_completor<br><br>|get_fields jline.SimpleCompletor getDeclaredFields<br><span style="color: rgb(0, 0, 0); font-style: italic;">candidates java0x1ba delimiter java0x1bb filter java0x1bc</span><br><br><span style="color: rgb(0, 0, 0);">The candidats seem an interesting option.<br><span style="color: rgb(51, 51, 255);">|array set s_fields [get_fields jline.SimpleCompletor getDeclaredFields]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|puts $s_fields(candidates)<br style="color: rgb(51, 51, 255);"></span><span style="font-style: italic;">java0x1c4<br><br></span><span style="color: rgb(51, 51, 255);">|$s_fields(candidates) setAccessible true</span><br><span style="color: rgb(51, 51, 255);">|get_name [$s_fields(candidates) get $s_completor]</span><br><span style="font-style: italic;">java.util.TreeSet</span><br><br><span style="color: rgb(51, 51, 255);">|[java::cast java.util.TreeSet [$s_fields(candidates) get $s_completor ]] add "true-blue"</span><br><br>There. we have added a new auto completion to the wadm.<br>You can test it by trying this in the wadm prompt.<br><span style="color: rgb(51, 51, 255);">|true-</span>[TAB] <br>and it should complete itself to<br><span style="color: rgb(51, 51, 255);">|true-blue </span><br><br>the complete reflect.tcl<br></span></span><font size="2"><span style="color: rgb(204, 0, 0);">=====================reflect.tcl============</span></font><br><span style="color: rgb(51, 51, 255);"><span style="color: rgb(0, 0, 0);"><font size="2"><span style="color: rgb(204, 0, 0);">namespace eval Reflect {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    namespace export get_class for_each_el get_fields get_name</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc get_class {cl} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return [java::field $cl class]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc get_name {i} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return [[$i getClass] getName]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    #get_fields jline.ConsoleReader getDeclaredFields</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc get_fields {cl method} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set arr [[java::field $cl class] $method]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set result {}</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        foreach {l} [for_each_el $arr {list [$e getName] $e}] {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            set result [concat $result $l]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return $result</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc for_each_el {arr cmd} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set size [$arr length]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set result {}</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        for {set i 0} {$i &lt; $size} {incr i} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            set e [$arr get $i]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            java::lock $e</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            lappend result [eval $cmd]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return $result</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span></font><br style="color: rgb(204, 0, 0);"></span></span><font size="2"><span style="color: rgb(204, 0, 0);">========================================<br><br><span style="color: rgb(0, 0, 0);"><font size="3">You can load this in your wadm to get the customized auto completions in your wadm shell.<br><br><font size="4"><span style="color: rgb(255, 0, 0);">Please be ware that we are modifying the private interfaces of the jline and wadm <br>and these may </span><span style="color: rgb(255, 0, 0);">change in further releases. Do not use this for serious work.</span><br style="color: rgb(255, 0, 0);"></font><br></font></span></span></font><font size="2"><span style="color: rgb(204, 0, 0);"></span></font>We will explore adding options to the command completion at a later time.<br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/the_java_connection_wadm_scripting">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
