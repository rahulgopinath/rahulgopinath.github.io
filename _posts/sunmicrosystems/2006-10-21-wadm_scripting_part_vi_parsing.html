---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
e: Walking with the unknown - parsing apache httpd.conf with wadm for SJS Web Server 7.0 (part VI)
---
{% raw %}
<div class="entry" id="wadm_scripting_part_vi_parsing">

	<h3 class="entry-title">
			Walking with the unknown - parsing apache httpd.conf with wadm for Sun Java System Web Server 7.0 (part VI)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 21, 2006</a>
</h4>

    <div class="entry-body">
                                        	
I have already shown you how to implement a ACL parser using wadm tcl. In this section, I will try to <br>take you along as I try to implement a simple parser for Apache httpd.conf and use it to implement a<br>similar configuration in Sun Java System WebServer.<br><br><h3>Looking at the apache httpd.conf</h3>The httpd.conf looks like this:<br><font style="color: rgb(0, 153, 0);" size="2"><br>=======================httpd.conf=============================<br># This is the main Apache HTTP server configuration file.  It contains the<br># configuration directives that give the server its instructions.<br>ServerRoot "/usr/local/apache2"<br>Listen 800<br>LoadModule authn_file_module modules/mod_authn_file.so<br>LoadModule mime_module modules/mod_mime.so<br><span style="color: rgb(0, 0, 0);">..snipped..</span><br>LoadModule rewrite_module modules/mod_rewrite.so<br></font><font style="color: rgb(0, 153, 0);" size="2"><span style="color: rgb(0, 0, 0);">..snipped..</span></font><br><font style="color: rgb(0, 153, 0);" size="2">ServerAdmin me@sun.com<br>ServerName www.example.com:80<br>DocumentRoot "/usr/local/www"<br>&lt;Directory /&gt;<br>    Options FollowSymLinks<br>    AllowOverride All<br>&lt;/Directory&gt;<br>ScriptAlias /codestriker/  /space/codestriker/codestriker-1.9.2-alpha-5/cgi-bin/<br>Alias /codestrikerhtml/  /space/codestriker/codestriker-1.9.2-alpha-5/html/<br>&lt;IfModule dir_module&gt;<br>    DirectoryIndex index.html<br>&lt;/IfModule&gt;<br>&lt;FilesMatch "\^\\.ht"&gt;<br>    Order allow,deny<br>    Deny from all<br>&lt;/FilesMatch&gt;<br>ErrorLog logs/error_log<br>LogLevel warn<br><br>&lt;IfModule log_config_module&gt;<br>    LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\"" combined<br>    LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b" common<br>    &lt;IfModule logio_module&gt;<br>      LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\" %I %O" combinedio<br>    &lt;/IfModule&gt;<br>    CustomLog logs/access_log common<br>&lt;/IfModule&gt;<br>DefaultType text/plain<br>&lt;IfModule mime_module&gt;<br>    TypesConfig conf/mime.types<br>    AddType application/x-compress .Z<br>    AddType application/x-gzip .gz .tgz<br>    AddOutputFilter INCLUDES .shtml<br>&lt;/IfModule&gt;<br>MIMEMagicFile conf/magic<br></font><font style="color: rgb(0, 153, 0);" size="2">==========================================================<br><br></font>
The files look like tcl except for the &lt;tag&gt; &lt;/tag&gt; stuff. Well it is possible to make tcl understand<br>that too. But other wise our strategy of defining procedures that are undefined until all the procedures<br>are defined holds good here too.<br><br>Since we are looking at a slightly more complex parsing than the acls, we will take a similar but slightly <br>different route.<br><br><h2>The Parsing.</h2>First let us see if we can capture the pattern that we noticed above.<br>here is our temporary conf file<br><font size="2"><span style="color: rgb(0, 153, 0);">===============temp.conf============</span><br style="color: rgb(0, 153, 0);"></font><font style="color: rgb(0, 153, 0);" size="2">ServerName agneyam<br></font><font style="color: rgb(0, 153, 0);" size="2">&lt;Directory /&gt;<br>    Options FollowSymLinks<br>    AllowOverride All<br>&lt;/Directory&gt;<br></font><font size="2"><span style="color: rgb(0, 153, 0);">==================================<br><br style="color: rgb(0, 153, 0);"></span></font>Here is the parser that we want to run on it.<font size="2"><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">==============apache.tcl============</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">namespace eval Apache {</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc parse {file} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set text [read_file $file]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        eval $text</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc read_file {file} {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set f [open $file r]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        set res [read -nonewline $f]</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        close $f</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        return $res</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}   </span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">===============================</span><br style="color: rgb(204, 0, 0);"></font><br>As you can see, We are just trying to apply the strategy previously described in ACL parsing.<br><br><span style="color: rgb(51, 51, 255);">|source apache.tcl</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::parse temp.conf</span><br style="color: rgb(51, 51, 255);"><span style="font-style: italic;">invalid command name "ServerName"</span><br><br>Ok so we implement the ServerName<br><font size="2"><span style="color: rgb(204, 0, 0);">===============================<br>    proc ServerName args {<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);">
<span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);">===============================</span><br style="color: rgb(204, 0, 0);">
</font><br><span style="color: rgb(51, 51, 255);">|source apache.tcl</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|Apache::parse temp.conf</span><br style="color: rgb(51, 51, 255);">
<span style="font-style: italic;">invalid command name "&lt;Directory"</span><br>
<br>While it is easy for us to define two more commands &lt;Directory and &lt;/Directory,<br>it seems that there should be a better way, What we can do is ask the tcl parser to<br>call us when it sees things of this sort. Tcl provides a convenient way for us to do <br>that .<br><br><h2>The Unknown.</h2>
Tcl calls a procedure called <span style="font-weight: bold;">unknown </span>when ever it finds a command or procedure<br>that was not previously defined. We will take advantage of that to get the &lt;tags&gt; <br>parsed.<br><br>What we will do is to redefine the <span style="font-weight: bold;">unknown </span>and make it into our own procedure.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">=========apache.tcl============<br>namespace eval Apache {<br>    variable stack<br><br>    proc parse {file} {<br>        set text [read_file $file]<br>        init_parse<br>        if [catch {eval $text} err] {<br>            puts "Eval:$err"<br>        }<br>        exit_parse<br>    }<br><br>    proc read_file {file} {<br>        set f [open $file r]<br>        set res [read -nonewline $f]<br>        close $f<br>        return $res<br>    }<br><br>    proc init_parse {} {<br>        rename ::unknown _unknown<br>        proc ::unknown args {<br>            Apache::invoke $args<br>        }<br>        set Apache::stack {}<br>    }<br><br>    proc exit_parse {} {<br>        rename ::unknown ""<br>        rename _unknown ::unknown<br>    }<br><br>    proc invoke arg {<br>        puts ": $arg"<br>    }<br>}<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===============================</span><br style="color: rgb(204, 0, 0);">
</font><br>Trying it<br><span style="color: rgb(51, 51, 255);">|source apache.tcl</span><br style="color: rgb(51, 51, 255);">

<span style="color: rgb(51, 51, 255);">|Apache::parse temp.conf</span><br style="color: rgb(51, 51, 255);">

<span style="font-style: italic;"></span><font style="font-style: italic;" size="2">: ServerName agneyam<br>: &lt;Directory /&gt;<br>: Options FollowSymLinks<br>: AllowOverride All<br>: &lt;/Directory&gt;<br></font><br>As you can see, We redefined and saved the current unknown to Apache::_unknown <br>before parsing, evaluated the file and after that changed the Apache::_unknown to the <br>global unknown.<br><br>Inside our parser, we redefined the unknown to call the Apache::invoke instead. so that<br>we get to interpret the procedures instead of tcl evaluator.<br><br>Now, we need to handle these tags better.<br><br><h3>Handling the tags</h3>Our aim is to just define procedures for all the normal directives (Those that are \*not\* of the<br>form &lt;tag&gt; or &lt;/tag&gt;) and leave the &lt;tag&gt;&lt;/tag&gt; for invoke. In the process we also will keep<br>track of any un-implemented procedures.<br><br><br><font style="color: rgb(204, 0, 0);" size="2">===================apache.tcl================<br>namespace eval Apache {<br>    variable stack<br>    variable not_impl<br>    set not_impl {}<br><br>    proc parse {file} {<br>        set text [read_file $file]<br>        init_parse<br>        if [catch {eval $text} err] {<br>            puts "Eval:$err"<br>        }<br>        exit_parse<br>    }<br><br>    proc show {} {<br>        puts "Not Implemented:"<br>        puts "________________"<br>        foreach {i} $Apache::not_impl {<br>            puts $i<br>        }<br>    }<br><br>    proc read_file {file} {<br>        set f [open $file r]<br>        set res [read -nonewline $f]<br>        close $f<br>        return $res<br>    }<br><br>    proc init_parse {} {<br>        rename ::unknown _unknown<br>        proc ::unknown args {<br>            Apache::invoke $args<br>        }<br>        set Apache::stack {}<br>    }<br><br>    proc exit_parse {} {<br>        rename ::unknown ""<br>        rename _unknown ::unknown<br>    }<br><br>    proc push_stack arg {<br>        set Apache::stack [concat $Apache::stack $arg]<br>    }<br>    proc pop_stack {} {<br>        set popd [lindex  $Apache::stack end]<br>        set Apache::stack [lrange $Apache::stack 0 end-1]<br>        return $popd<br>    }<br><br>    proc invoke arg {<br>        set word [lindex $arg 0]<br>        switch -regexp $word {<br>            {\^ \*&lt;/.\*} {<br>                if {[regexp {\^ \*&lt; \*/([\^ ]+) \*&gt; \*$} $arg all one]} {<br>                    set p [pop_stack]<br>                    invoke_proc $p -exit<br>                }<br>                return<br>            }<br><br>            {\^ \*&lt;.\*} {<br>                if {[regexp {\^ \*&lt;([\^ ]+) \*(.\*)&gt; \*$} $arg all one rest]} {<br>                    push_stack $one<br>                    invoke_proc $one -init $rest<br>                }<br>                return<br>            }<br><br>            default {<br>                #the only directives that come here must be those that are not done.<br>                notimpl $word<br>            }<br>       }<br>    }<br>    proc invoke_proc {p args} {<br>        if [llength [info proc $p]] {<br>            $p $args<br>        } else {<br>            notimpl $p<br>        }<br>    }<br><br>    proc notimpl arg {<br>        set Apache::not_impl [concat $Apache::not_impl $arg]<br>    }<br>}<br><br></font><font style="color: rgb(204, 0, 0);" size="2">=============================================</font><br><br>As you can see, when we find a tag of sort &lt;Directory&gt; or &lt;IfModule&gt; we call<br>the corresponding procedure - eg: 'Directory' with the argument -init along with<br>the rest of arguments we got in the declaration. <br>When we get the end of tag (&lt;/Directory&gt;) we simply call Directory -exit.<br><br><span style="font-weight: bold;">Using it</span><br><br><span style="color: rgb(51, 51, 255);">|source apache.tcl      </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::parse temp.conf</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::show           </span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">Not Implemented:<br>________________<br>ServerName<br>Directory<br>Options<br>AllowOverride</font><br><br>Let us add some thing more to the apache httpd.conf<br><font size="2"><span style="color: rgb(0, 153, 0);">===============temp.conf============</span><br style="color: rgb(0, 153, 0);">
</font><font style="color: rgb(0, 153, 0);" size="2">ServerName agneyam<br>&lt;IfModule log_config_module&gt;<br>    LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\"" combined<br>    LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b" common<br>    &lt;IfModule logio_module&gt;<br>      LogFormat "%h %l %u %t \\"%r\\" %&gt;s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\" %I %O" combinedio<br>    &lt;/IfModule&gt;<br>    CustomLog logs/access_log common<br>&lt;/IfModule&gt;<br></font><font style="color: rgb(0, 153, 0);" size="2">&lt;Directory /&gt;<br>
    Options FollowSymLinks<br>    AllowOverride All<br>&lt;/Directory&gt;<br></font><font size="2"><span style="color: rgb(0, 153, 0);">==================================<br>
</span></font><br><h3>Implementing the IfModule</h3>There are two ways we can handle the IfModule,<br>1) Do it statically, That is evaluate the IfModule with what is available in the current<br>    LoadedModules array (Assume such an array is constructed and is available.)<br><br>2) Do it dynamically, Instead of Evaluating the IfModule during parsing state, add the<br>    condition to the script that will get evaluated when the script is run.<br><br>We will go for the second option since that is more powerful.<br><br><font style="color: rgb(204, 0, 0);" size="2">=================apache.tcl====================<br>namespace eval Apache {<br>    variable stack<br>    variable not_impl<br><br>    #commands to be evaluated<br>    variable text<br><br>    proc parse {file} {<br>        set text [read_file $file]<br>        regsub -all {\\"&gt;} $text {\\" &gt;} text<br>        pre_conf<br>        init_parse<br>        if [catch {eval $text} err] {<br>            puts "Eval:$err"<br>        }<br>        exit_parse<br>    }<br><br>    proc pre_conf {} {<br>        set Apache::stack {}<br>        set Apache::not_impl {}<br>        set Apache::text {}<br>        array set Apache::info {}<br>        array set Apache::module {}<br>    }<br><br>    proc show {} {<br>        puts "Not Implemented:"<br>        puts "________________"<br>        foreach {i} [lsort [uniq $Apache::not_impl]] { puts $i }<br>        puts "________________"<br>        foreach {i} $Apache::text { puts $i }<br>    }<br><br>    proc uniq {l} {<br>        if { $l == {} } { return {} }<br>        array set arr {}<br>        foreach element $l { set arr($element) "" }<br>        set result [array names arr]<br>        return $result<br>    }<br><br>    proc read_file {file} {<br>        set f [open $file r]<br>        set res [read -nonewline $f]<br>        close $f<br>        return $res<br>    }<br><br>    proc | args {<br>        lappend Apache::text [join $arg " "]<br>    }<br><br>    proc init_parse {} {<br>        rename ::unknown _unknown<br>        proc ::unknown args {<br>            Apache::invoke $args<br>        }<br>    }<br><br>    proc exit_parse {} {<br>        rename ::unknown ""<br>        rename _unknown ::unknown<br>    }<br><br>    proc push_stack arg {<br>        set Apache::stack [concat $Apache::stack $arg]<br>    }<br><br>    proc pop_stack {} {<br>        set popd [lindex  $Apache::stack end]<br>        set Apache::stack [lrange $Apache::stack 0 end-1]<br>        return $popd<br>    }<br><br>    proc invoke arg {<br>        set word [lindex $arg 0]<br>        switch -regexp $word {<br>            {\^ \*&lt;/.\*} {<br>                if {[regexp {\^ \*&lt; \*/([\^ ]+) \*&gt; \*$} $arg all one]} {<br>                    set p [pop_stack]<br>                    invoke_proc $p -exit<br>                }<br>                return<br>            }<br><br>            {\^ \*&lt;.\*} {<br>                if {[regexp {\^ \*&lt;([\^ ]+) \*(.\*)&gt; \*$} $arg all one rest]} {<br>                    push_stack $one<br>                    invoke_proc $one -init $rest<br>                }<br>                return<br>            }<br><br>            default {<br>                #the only directives that come here must be those that are not done.<br>                notimpl $word $arg<br>            }<br>       }<br>    }<br>    proc invoke_proc {p args} {<br>        if [llength [info proc $p]] {<br>            $p $args<br>        } else {<br>            notimpl $p $args<br>        }<br>    }<br><br>    proc notimpl {p arg} {<br>        #Uncomment the next line to get the not implenented procedures<br>        #in their context.<br>        | "#NI ($p) $arg"<br>        set Apache::not_impl [concat $Apache::not_impl $p]<br>    }<br><br>    #==================================================<br>    #       The Engine<br>    #==================================================<br><br>    proc IfModule args {<br>        set arg [lindex $args 0]<br>        switch -- [lindex $arg 0] {<br>            {-init} {<br>                set cur [lindex $arg 1]<br>                #check if it is of type !xxxx , if it is take the reverse.<br>               if {[regexp {\^ \*!([\^ ]+)$} $cur all one] } {<br>                    | "if {!\\[info exist Apache::module($one)\\]}  {" ;#}<br>                } else {<br>                    | "if \\[info exist Apache::module($cur)\\]  {" ;#}<br>                }<br>            }<br>            {-exit} {<br>                #;{<br>                | "}"<br>            }<br>        }<br>    }<br>}<br></font><font style="color: rgb(204, 0, 0);" size="2">=============================================</font><br><br><h4>Using it,</h4>
<span style="color: rgb(51, 51, 255);">|source apache.tcl      </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::parse temp.conf</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::show           </span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;"></span><span style="font-style: italic;">Not Implemented:<br>________________<br>AllowOverride<br>CustomLog<br>Directory<br>LogFormat<br>Options<br>ServerName<br>________________<br>#NI (ServerName) ServerName agneyam<br>if [info exist Apache::module(log_config_module)]  {<br>#NI (LogFormat) LogFormat {%h %l %u %t "%r" %&gt;s %b "%{Referer}i" "%{User-Agent}i"} combined<br>#NI (LogFormat) LogFormat {%h %l %u %t "%r" %&gt;s %b} common<br>if [info exist Apache::module(logio_module)]  {<br>#NI (LogFormat) LogFormat {%h %l %u %t "%r" %&gt;s %b "%{Referer}i" "%{User-Agent}i" %I %O} combinedio<br>}<br>#NI (CustomLog) CustomLog logs/access_log common<br>}<br>#NI (Directory) -init /<br>#NI (Options) Options FollowSymLinks<br>#NI (AllowOverride) AllowOverride All<br>#NI (Directory) -exit<br></span><br></font>As you can see, the IfModule adds if condition to the script produced at the end. Now let us <br>turn our attension to the engine.<br><h3>The Engine</h3>The Engine is very simple. You have to define a procedure for each directive you want to <br>translate. You will be given the arguments via the $args list. After figuring out what commands to call,<br>just call them using the '|' procedure. (as demonstrated in the IfModule.)<br><br>Handling the tags are also simple as shown in the IfModule, each such procedure (say Directory)<br>will take a list whose first element will be '-init' when it enters the tag, and '-exit' when it exits the tag.<br>You will also get the rest of arguments to tag entry along with -init.<br><br>(Look for the comment with #Engine to see the engine starting.)<br><br><font style="color: rgb(204, 0, 0);" size="2">=================apache.tcl===================<br>namespace eval Apache {<br>    variable stack<br>    variable not_impl<br>    variable info<br>    variable module<br><br>    #commands to be evaluated<br>    variable text<br><br>    proc parse {file} {<br>        set text [read_file $file]<br>        #massage it gently.<br>        regsub -all {\\"&gt;} $text {\\" &gt;} text<br><br>        pre_conf<br>        init_parse<br>        if [catch {eval $text} err] {<br>            puts "Eval:$err"<br>        }<br>        exit_parse<br>    }<br><br>    proc pre_conf {} {<br>        set Apache::stack {}<br>        set Apache::not_impl {}<br>        set Apache::text {}<br>        array set Apache::info {}<br>        array set Apache::module {}<br>        #--------------------------------<br>        set Apache::info(config) apache<br>        set Apache::info(config_port) 10000<br>        set Apache::info(server_name) apache_mig<br>        set Apache::info(default_vs) $Apache::info(config)<br>        | create-config --http-port $Apache::info(config_port) --server-name $Apache::info(server_name) $Apache::info(config)<br> <br>    }<br><br>    proc show {} {<br>        puts "Not Implemented:"<br>        puts "________________"<br>        foreach {i} [lsort [uniq $Apache::not_impl]] { puts $i }<br>        puts "________________"<br>        foreach {i} $Apache::text { puts $i }<br>    }<br><br>    proc uniq {l} {<br>        if { $l == {} } { return {} }<br>        array set arr {}<br>        foreach element $l { set arr($element) "" }<br>        set result [array names arr]<br>        return $result<br>    }<br><br><br>    proc read_file {file} {<br>        set f [open $file r]<br>        set res [read -nonewline $f]<br>        close $f<br>        return $res<br>    }<br><br>    proc | args {<br>        lappend Apache::text [join $args " "]<br>    }<br><br>    proc init_parse {} {<br>        rename ::unknown _unknown<br>        proc ::unknown args {<br>            Apache::invoke $args<br>        }<br>    }<br><br>    proc exit_parse {} {<br>        rename ::unknown ""<br>        rename _unknown ::unknown<br>    }<br><br>    proc push_stack arg {<br>        set Apache::stack [concat $Apache::stack $arg]<br>    }<br><br>    proc pop_stack {} {<br>        set popd [lindex  $Apache::stack end]<br>        set Apache::stack [lrange $Apache::stack 0 end-1]<br>        return $popd<br>    }<br><br>    proc invoke arg {<br>        set word [lindex $arg 0]<br>        switch -regexp $word {<br>            {\^ \*&lt;/.\*} {<br>                if {[regexp {\^ \*&lt; \*/([\^ ]+) \*&gt; \*$} $arg all one]} {<br>                    set p [pop_stack]<br>                    invoke_proc $p -exit<br>                }<br>                return<br>            }<br><br>            {\^ \*&lt;.\*} {<br>                if {[regexp {\^ \*&lt;([\^ ]+) \*(.\*)&gt; \*$} $arg all one rest]} {<br>                    push_stack $one<br>                    invoke_proc $one -init $rest<br>                }<br>                return<br>            }<br><br>            default {<br>                #the only directives that come here must be those that are not done.<br>                notimpl $word $arg<br>            }<br>       }<br>    }<br>    proc invoke_proc {p args} {<br>        if [llength [info proc $p]] {<br>            $p $args<br>        } else {<br>            notimpl $p $args<br>        }<br>    }<br><br>    proc notimpl {p arg} {<br>        #Uncomment the next line to get the not implenented procedures<br>        #in their context.<br>        #| "#NI ($p) $arg"<br>        set Apache::not_impl [concat $Apache::not_impl $p]<br>    }<br><br>    #==================================================<br>    #       The Engine<br>    #==================================================<br><br>    proc IfModule args {<br>        set arg [lindex $args 0]<br>        switch -- [lindex $arg 0] {<br>            {-init} {<br>                set cur [lindex $arg 1]<br>                #check if it is of type !xxxx , if it is take the reverse.<br>               if {[regexp {\^ \*!([\^ ]+)$} $cur all one] } {<br>                    | "if {!\\[info exist Apache::module($one)\\]}  {" ;#}<br>                } else {<br>                    | "if \\[info exist Apache::module($cur)\\]  {" ;#}<br>                }<br>            }<br>            {-exit} {<br>                #;{<br>                | "}"<br>            }<br>        }<br>    }<br><br>    proc ServerRoot args {<br>        set Apache::info(server_root) $args<br>    }<br><br>    proc ServerAdmin args {<br>        set Apache::info(server_admin) [lindex $args 0]<br>    }<br><br>    proc ServerName args {<br>        set Apache::info(server_name) [lindex $args 0]<br>    }<br><br>    proc DocumentRoot args {<br>        set droot [lindex $args 0]<br>        | set-virtual-server-prop --config $Apache::info(config) --vs $Apache::info(default_vs) \\<br>            document-root=$droot<br>    }<br><br>    proc LogLevel args {<br>        set arg [lindex $args 0]<br>        set log warning<br>        #emerg System is unstable<br>        #alert Immediate action required<br>        #crit Critical error<br>        #error Non-critical error<br>        #warn Warning<br>        #notice Normal but significant<br>        #info Informational<br>        #debug Debug level<br><br>        #finest<br>        #finer<br>        #fine<br>        #info<br>        #warning<br>        #failure<br>        #config<br>        #security<br>        #catastrophe<br><br>        switch $arg -- {<br>            emerg {<br>                set log catastrophe<br>            }<br>            alert {<br>                set log failure<br>            }<br>            crit {<br>                set log failure<br>            }<br>            errof {<br>                set log warning<br>            }<br>            warn {<br>                set log warning<br>            }<br>            notice {<br>                set log info<br>            }<br>            info {<br>                set log fine<br>            }<br>            debug {<br>                set log finest<br>            }<br>        }<br><br>        | set-log-prop --config $Apache::info(config) log-level=$log<br>    }<br><br>    proc ErrorLog args {<br>        set log [lindex $args 0]<br>        | set-log-prop --config $Apache::info(config) log-file=$log<br>    }<br><br>    proc AccessFileName args {<br>        set af [lindex $args 0]<br>        | enable-htaccess --config $Apache::info(config) --vs $Apache::info(default_vs) \\<br>            --config-file $af<br>    }<br><br>    proc AddType args {<br>        set type [lindex $args 0]<br>        set ext [join [lrange $args 1 end] ","]<br>        regsub -all {\\.} $ext {} ext<br>        | create-mime-type --config $Apache::info(config) --extensions $ext $type<br>    }<br><br>    proc DefaultType args {<br>        #this does not have an equivalent in sjswebsrever.<br>    }<br><br>    proc Alias args {<br>        set alias [lindex $args 0]<br>        set fs [lindex $args 1]<br>        | create-document-dir --config $Apache::info(config) --uri-prefix $alias \\<br>            --directory $fs --vs $Apache::info(default_vs)<br>    }<br><br>    proc CgiAlias args {<br>        set alias [lindex $args 0]<br>        set fs [lindex $args 1]<br>        | create-cgi-dir --config $Apache::info(config) --uri-prefix $alias \\<br>            --directory $fs --vs $Apache::info(default_vs)<br>    }<br><br>    proc TypesConfig args {<br>        set mf [lindex $args 0]<br>        | set-config-prop --config $Apache::info(config) mime-file=$mf<br>    }<br><br>    proc LoadModule args {<br>        | "set Apache::module([lindex $args 0]) [lrange $args 1 end]"<br>    }<br><br>    proc Listen args {<br>        #listen could come in two forms:<br>        #8000<br>        #192.168.1.1:8000<br>        set port 0<br>        set ip {}<br><br>        set arg [lindex $args 0]<br>        switch -regexp -- $arg {<br>            {:} {<br>                regexp {(.+):(.+)} $arg all ip port<br>            }<br>            default {<br>                set port $arg<br>            }<br>        }<br><br>        #The listen could happen multiple times. when it does, we need to change the http-listener name<br>        set lst http-listener-1<br>        if [info exists Apache::info(http-listener-cur)] {<br>            set lst "$Apache::info(http-listener-cur)-1"<br>            set ipprop ""<br>            if [string length $ip] {<br>                set ipprop "--ip $ip"<br>            }<br>            eval "| create-http-listener --config $Apache::info(config) \\<br>                     --listener-port $port $ipprop \\<br>                    --server-name $Apache::info(server_name) \\<br>                    --default-virtual-server-name $Apache::info(default_vs) \\<br>                    $ipprop $lst"<br><br>            set Apache::info(http-listener-cur) $lst<br>        } else {<br>            set ipprop ""<br>            if [string length $ip] {<br>                set ipprop "ip=$ip"<br>            }<br>            eval "| set-http-listener-prop --config $Apache::info(config) \\<br>                    --http-listener $lst port=$port $ipprop"<br>        }<br>    }<br>}<br></font><font style="color: rgb(204, 0, 0);" size="2">=============================================</font><br><br><h4>Using It</h4>
<span style="color: rgb(51, 51, 255);">|source apache.tcl       </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::parse httpd.conf</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Apache::show            </span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">Not Implemented:<br>________________<br>Allow<br>AllowOverride<br>CustomLog<br>Deny<br>Directory<br>DirectoryIndex<br>FilesMatch<br>Group<br>LogFormat<br>Options<br>Order<br>SSLRandomSeed<br>ScriptAlias<br>SetHandler<br>User<br>________________<br>create-config --http-port 10000 --server-name apache_mig apache<br>set-http-listener-prop --config apache --http-listener http-listener-1 port=800<br>if {![info exist Apache::module(mpm_winnt_module)]}  {<br>if {![info exist Apache::module(mpm_netware_module)]}  {<br>}<br>}<br>set-virtual-server-prop --config apache --vs apache document-root=/usr/local/www<br>create-document-dir --config apache --uri-prefix /codestrikerhtml/ --directory /space/codestriker/codestriker-1.9.2-alpha-5/html/ --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_scratch --directory /usr/local/lxr_scratch --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_40rtm --directory /usr/local/lxr_40rtm --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_36rtm --directory /usr/local/lxr_36rtm --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_nspr --directory /usr/local/lxr_nspr --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_nss --directory /usr/local/lxr_nss --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_squid --directory /usr/local/lxr_squid --vs apache<br>create-document-dir --config apache --uri-prefix /lxr_ws70 --directory /usr/local/lxr_ws70 --vs apache<br>if [info exist Apache::module(dir_module)]  {<br>}<br>enable-htaccess --config apache --vs apache --config-file .htaccess<br>set-log-prop --config apache log-file=logs/error_log<br>set-log-prop --config apache log-level=warning<br>if [info exist Apache::module(log_config_module)]  {<br>if [info exist Apache::module(logio_module)]  {<br>}<br>}<br>if [info exist Apache::module(alias_module)]  {<br>}<br>if [info exist Apache::module(cgid_module)]  {<br>}<br>if [info exist Apache::module(mime_module)]  {<br>set-config-prop --config apache mime-file=conf/mime.types<br>create-mime-type --config apache --extensions Z application/x-compress<br>create-mime-type --config apache --extensions gz,tgz application/x-gzip<br>}<br>if [info exist Apache::module(ssl_module)]  {<br>}<br></font><br><br>The current apache.tcl is available <a href="../../blue/resource/apache.tcl" target="_self">here</a><br><br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/wadm_scripting_part_vi_parsing">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
