---
layout: post
categories : sunblog
tagline: "."
tags : [sunmicrosystems blog sun]
e: The mists of time - implementing cron - wadm scripting (part X)
---
{% raw  %}
<div class="entry" id="the_mists_of_time_implementing">

	<h3 class="entry-title">
			The mists of time :implementing cron - wadm scripting (part X)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 29, 2006</a>
</h4>

    <div class="entry-body">
                                        	
There are many times when you would want to do some sequence of<br>actions periodically. - like renewing your certificates, rotating the logs<br> bring up and bringing down instances and virtual servers based on day<br>and time etc.<br><br>Most people run the Webserver in some kind of unix which means <br>that they already have and are familiar with a utility that will help them do<br>just that, the crontab.<br><br>The Sun Java System Web Server 7.0 also ships with<br>an event scheduler that will help you set up these actions that will be <br>repeated in the time frame that you specify. One of the reasons for the <br>scheduler getting integrated into the Webserver was that we wanted to<br> provide an administrative interface to the scheduling facility. <br><br>Since sometimes the Webserver administrators may not be the sysadmins<br>for the machine in which the server runs on, and also because the setting<br>up of cron in unix required access to the machine itself, It was better to <br>provide a scheduler that was different from the machine cron that was <br>specific to the Webserver alone. <br><br>Though the current Scheduler in Webserver does have an administrative<br>remote interface now, a small short coming is that inorder to allow any<br> kind of complex action (Any thing that requires a condition or a dependecy)<br>you still need access to the machine in which the Webserver runs (over and <br>above administrative access to the Webserver). This is because the only <br>way you can do such things is to write it in shell script and then schedule<br>that shell script to run.<br><br>While it would have been a great idea to provide callbacks from the <br>Scheduler to the wadm, it is not there currently (Unfortunately). <br><br>Moreover, you can not  schedule events across the cluster but are restricted<br>to a particular configuration for each event.<br><font size="2"><i>|create-event   </i></font><font size="2"><i><br></i></font><font size="2"><i>Usage: create-event --help|-?</i></font><font size="2"><i><br></i></font><font size="2"><i>      or   create-event [--echo] [--no-prompt] [--verbose] [--no-enabled] --config=name <br>    --command=restart|reconfig|rotate-log|rotate-access-log|update-crl|commandline <br>   ( (--time=hh:mm [--month=1-12] [--day-of-week=sun/mon/tue/wed/thu/fri/sat] <br>    [--day-of-month=1-31]) | --interval=60-86400(seconds) )</i></font><font size="2"><i><br></i></font><font size="2"><i>    CLI014 config is a required option.</i></font><font size="2"><br></font><br>Because it is running on the webserverd, it also means that it is machine specific<br>(ie) the command line specified would run once in each machine. while it is desirable<br>in some cases, it is not so in others where you just want to execute a command cluster <br>wide.<br><br>let us see how much wadm will be able to help us in this matter.<br><br><h4>Deciding on the API<br>
</h4>We will try and have some similarity with the crontab, also it will be nice to make the<br>API look like a procedure that gets executed on time.<br><br><font size="2"><font color="#009900">on name "\* \* \* \* \* \*" {</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">         if {certs-expired} {</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">                 renew-selfsigned-cert</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">         }</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">         rotate-logs</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">         cleanup</font></font><font size="2"><font color="#009900"><br></font></font><font size="2"><font color="#009900">}</font></font><br><br>Implementation<br><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br><font style="color: rgb(204, 0, 0);" size="2">namespace eval Cron {<br>    variable units<br>    variable schedule<br>    proc on {name time script} {<br>        array set schedule [parse_time $time]<br>        set schedule(script) $script<br>        set Cron::schedule($name) [array get schedule]<br>        persist<br>        return {}<br>    }<br><br>    proc init {} {<br>        set Cron::units {second minute hour day_of_month month day_of_week}<br>    }<br><br>    proc parse_time time {<br>        array set parsed {}<br>        set time [validate $time]<br>        foreach unit $Cron::units value $time {<br>            set parsed($unit) $value<br>        }<br>        return [array get parsed]<br>    }<br>    proc persist {} {<br>    }<br>    proc validate {time} {<br>        return $time<br>    }<br>}<br></font><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br><br><span style="color: rgb(51, 51, 255);">|source cron.tcl                      </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::on mexico "\* \* \* \*" { puts blue }</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::init                           </span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">second minute hour day_of_month month day_of_week</span></font><br><span style="color: rgb(51, 51, 255);">|Cron::on blue "\* \* \* \*" { puts true}</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|puts $Cron::schedule(blue)</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">hour \* script { puts true } day_of_week {} second \* day_of_month \* month {} minute \*</span></font><br><br>We have set aside the validation and persistance for later. They are not <br>strictly needed for simple operations.<br>   <br><h4>Scheduling</h4>Now we need to find a way to get these to be invoked periodicaly, and Tcl provides<br>just what we want in the form of <span style="font-weight: bold;">after</span> command.<br><br><span style="color: rgb(51, 51, 255);">|after</span><br><font size="2">wrong # args: should be "after option ?arg arg ...?"</font><br>The arguments of the after are the number of milliseconds to wait and the procedure<br>to run after that wait. so adding the after command to our script,<br><br><font style="color: rgb(204, 0, 0);" size="2">========================================<br>    variable id<br></font><font style="color: rgb(204, 0, 0);" size="2">    proc start {} {<br>        run </font><font style="color: rgb(204, 0, 0);" size="2">[clock seconds]</font><br><font style="color: rgb(204, 0, 0);" size="2">        catch {after cancel $Cron::id} err<br>        set Cron::id [after 1000 Cron::start]<br>    }<br><br>    proc run {now} {<br>        foreach id [array names Cron::schedule] {<br>            puts "$id $now"<br>        }<br>    }<br></font><br><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br><br>Here we print each scheduled entry with 1 second periodicity.<br>all it remains to do is to change the puts to invocation after determining<br>if the schdedule matches to the current time.<br><br>Checking it out.<br><span style="color: rgb(51, 51, 255);">|source cron.tcl                      </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::init                           </span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">second minute hour day_of_month month day_of_week</font><br><span style="color: rgb(51, 51, 255);">|Cron::on blue "\* \* \* \*" { puts true}</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::start      </span>                    <br><font size="2"><span style="font-style: italic;">blue 1162126366</span><br style="font-style: italic;"><span style="font-style: italic;">blue 1162126367</span><br style="font-style: italic;"><span style="font-style: italic;">blue 1162126368</span><br style="font-style: italic;"></font><br>Matching the time.<br>Now we need to match the scheduled time for each id, and invoke<br>it if the time matches the current.<br><br><h4>A bug</h4>Unfortunately due to a bug in jacl implementation of tcl, the list entered directly<br>in the console which contains new lines is used with the newlines stripped out,<br>ie:<br><span style="color: rgb(51, 51, 255);">|puts {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">a</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">b</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">c</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br><font size="2"><span style="font-style: italic;">abc</span><br style="font-style: italic;"></font><br>
while in tclsh<br><span style="color: rgb(51, 51, 255);">tclsh&gt;puts {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">a</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">b</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">c</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">a</span><br style="font-style: italic;"><span style="font-style: italic;">b</span><br style="font-style: italic;"><span style="font-style: italic;">c</span><br style="font-style: italic;"><br><font size="3">Due to this reason, when you enter scripts, you will have to terminate each line by a ';'</font><br style="font-style: italic;"></font><br><h4>Minimal Cron</h4>
<font style="color: rgb(204, 0, 0);" size="2">========================================<br>namespace eval Cron {<br>    variable units<br>    variable schedule<br>    variable id<br>    variable fmt<br><br>    set Cron::units {second minute hour day_of_month month day_of_week}<br>    set Cron::fmt {%S %M %H %d %m %w}<br><br>    foreach u $Cron::units f $Cron::fmt {<br>        eval "proc $u {time} { clock format \\$time -format $f }"<br>    }<br><br>    proc on {name time script} {<br>        set Cron::schedule($name) [concat [parse_time $time] "script {$script}"]<br>        return {}<br>    }<br><br>    proc parse_time time {<br>        array set parsed {}<br>        foreach unit $Cron::units value $time {<br>            if [llength $value] {<br>                set parsed($unit) $value<br>            } else {<br>                set parsed($unit) \*<br>            }<br>        }<br>        return [array get parsed]<br>    }<br><br>    proc start {} {<br>        run </font><font style="color: rgb(204, 0, 0);" size="2">[clock seconds]</font><br><font style="color: rgb(204, 0, 0);" size="2">        catch {after cancel $Cron::id} err<br>        set Cron::id [after 1000 Cron::start]<br>    }<br><br>    proc run {now} {<br>        foreach id [array names Cron::schedule] {<br>            runone $id $now<br>        }<br>    }<br><br>    proc runone {id now} {<br>        array set time $Cron::schedule($id)<br>        foreach unit $Cron::units {<br>            if {![includes $time($unit) [$unit $now]]} { <br>                return <br>            }<br>        }<br>        if [catch {eval $time(script)} err] {<br>            puts "Error($id):$err"<br>        }<br>    }<br><br>    proc includes {lst var} {<br>        regsub {\^0+(.+)$} $var {\\1} var<br>        foreach p $lst {<br>            if {[lsearch -glob $var $p] &gt; -1} {<br>                return 1<br>            }<br>        }<br>        return 0<br>    }<br>}<br></font><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br><h4 style="font-weight: bold;">Some shortcuts.<br><span style="font-weight: normal;"></span>
</h4>
<h4 style="font-weight: bold;"><span style="font-weight: normal;">You may have noticed this line</span></h4>
<font style="color: rgb(204, 0, 0);" size="2">    foreach u $Cron::units f $Cron::fmt {<br>        eval "proc $u {time} { clock format \\$time -format $f }"<br>    }<br></font>where I am making use of the tcl's dynamic evaluation capabilities<br>to create similar procedures in a loop. It allows us to abstract further<br>and reduce duplication of code.<br><br><h4>Using it</h4>
<span style="color: rgb(51, 51, 255);">|source cron.tcl           </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::on blue \* {         </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts one;</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts two;</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts three;</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:}</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::start</span><br><font size="2"><span style="font-style: italic;">one</span><br style="font-style: italic;"><span style="font-style: italic;">two</span><br style="font-style: italic;"><span style="font-style: italic;">three</span><br style="font-style: italic;"><span style="font-style: italic;">one</span><br style="font-style: italic;"><span style="font-style: italic;">two</span><br style="font-style: italic;"><span style="font-style: italic;">three</span><br style="font-style: italic;"></font><br>As noted above, please insert the ';' to terminate each lines.,<br><br><h4>Persistance</h4>Because we are dealing with tcl, the data always has a string representaion<br>that can be used to recreate the data. so all it takes us to implement persistance <br>is<br><br><font style="color: rgb(204, 0, 0);" size="2">========================================<br>    proc persist {} {<br>        set f [open $Cron::ifile w]<br>        puts $f [array get Cron::schedule]<br>        close $f<br>    }<br>    proc init {} {<br>       catch {<br>            set f [open $Cron::ifile r]<br>            array set Cron::schedule [read -nonewline $f]<br>            close $f<br>        } err <br>        start<br>        return {}<br>    }<br></font><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br>We just write the Cron::schedule to a file '.cron.wadm' and<br>read it back when we startup.<br><br>The completed cron with validation and listing is available <a href="../../blue/resource/cron.tcl" target="_self">here</a><br>I have removed the seconds part from the cron since it is not very useful <br>except during debugging.<br><h4>Using It</h4>
<br><span style="color: rgb(51, 51, 255);">|source cron.tcl  </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::init</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::on blue \* {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts 1</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:}</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">1</span><br style="font-style: italic;"><span style="font-style: italic;">1</span><br style="font-style: italic;"><span style="font-style: italic;">1</span><br style="font-style: italic;"><span style="font-style: italic;">1</span></font><br><span style="color: rgb(51, 51, 255);">|Cron::stop</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::ls</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">blue</span></font><br><span style="color: rgb(51, 51, 255);">|Cron::ls -l</span><br><font style="font-style: italic;" size="2">blue =&gt; hour \* day_of_week \* second \* day_of_month \* month \* minute \* script {puts 1}</font><br><span style="color: rgb(51, 51, 255);">|Cron::on newblue {{0 1} 1} {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts mex;                 </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts mee;</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:}</span><br><span style="color: rgb(51, 51, 255);">|Cron::rm blue</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::ls -l        </span>       <br><font size="2"><span style="font-style: italic;">newblue =&gt; hour \* day_of_week \* second {0 1} day_of_month \* month \* minute \* script {puts mex;puts mee;}</span><br style="font-style: italic;"><span style="font-style: italic;">....</span><br style="font-style: italic;"><span style="font-style: italic;">mex</span><br style="font-style: italic;"><span style="font-style: italic;">mee</span><br style="font-style: italic;"><span style="font-style: italic;">mex</span><br style="font-style: italic;"><span style="font-style: italic;">mee</span></font><br><br>I have removed the seconds part from the cron since it is not very useful <br>
except during debugging.<br>

<br><span style="color: rgb(51, 51, 255);">|source cron.tcl  </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::init       </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::on blue \* {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:puts here;</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">:}</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Cron::ls -l</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">blue =&gt; hour \* day_of_week \* day_of_month \* month \* minute \* script {puts here;}</span><br style="font-style: italic;"><span style="font-style: italic;">here</span><br style="font-style: italic;"><span style="font-style: italic;">here</span><br style="font-style: italic;"></font><br>The completed cron is available <a href="../../blue/resource/cron.tcl" target="_self">here</a><br>
<br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/the_mists_of_time_implementing">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}

