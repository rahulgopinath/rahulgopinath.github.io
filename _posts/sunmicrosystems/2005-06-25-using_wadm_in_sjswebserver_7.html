---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
categories : sunblog
e: (wadm I) Using wadm in  Sun Java System Web Server 7.0
---
{% raw %}
<div class="entry" id="using_wadm_in_sjswebserver_7">

	<h3 class="entry-title">
			Using wadm in  Sun Java System Web Server 7.0 (part I)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Jun 25, 2006</a>
</h4>

    <div class="entry-body">
                                        	
<br>          As you may have noticed, the Sun Java System Web Server 7.0 came out with a revamped command-line interface
that incorporates a scripting <br>framework. <br>This scripting framework is based on
JACL a java-vm implementation of the TCL language.

    During the start of 7.0 effort, multiple <br>languages were evaluated to provide
the scripting solution that we wanted. The Application server even had their own
home grown <br>solution called asadmin that provided a very skeletal interface to 
command invocation (I wouldn't call that a language yet.)

    <br>We were looking for the following features so as to make the use of our
scripting interface painless for the users.

<br><h3>Our needs...
</h3>
<ol><li>We needed to provide the same kind of interface both as stand-alone command 
   line and also asexposed to scripting with in the language environment. This
   meant that the language needed to be as close to the shell scripting syntax
   as possible. <br>
</li></ol>            This was high priority also because we recognized that most of
   our customers were sysadmins who will be more familiar with <br>            the shell 
   scripting    environment than with any other language.

<br><br>     2. Most of our enterprise customers have home-grown solutions that rely on 
   configuration files and shell scripts to achieve large scale clustering.
   <br>          Attention was paid to the mouldability of the language to emulate these
   systems so that the barrier of entry would be low for our <br>          scripting 
   framework.

<br><br>     3. We needed a powerful system that ran on top of JVM, (did not have the
   resources to create or adapt any new language <br>           to the jvm platform)

<br><br>     4. A system that would allow us to hammer out simple scripts for simple tasks,
   and also keep its cool on complex tasks was felt to be <br>           the need of the hour 
   (especially because our largest customers had to write very complex
   solutions to maintain their farms)

We also <br>           wanted to support only a single language since having multiple
languages would fragment the users and the community using the wadm.


<br>           We evaluated the following based on these guiding principles.

<h3>Languages we looked at</h3>
\*  scheme (jscheme)
<br>\*  python (jython)
<br>\*  ruby   (jruby)
<br>\*  perl
<br>\*  shell (various _sh)
<br>\*  asadmin
<br>\*  groovy
<br>\*  beanshell
<br>\*  javascript (rhino)

<br><br>The first one we looked at was <b>asadmin</b>, one because we had lots of in-house
expertise on it, and second, it was already being used in <br>one of the sister
products. Sadly it fell far short of most of the requirements.

<br><br>The various shells like <b>bash,zsh,ksh,csh</b> started out as favorites because
they had the shell syntax (well, they are the shells). but did not <br>make it 
due to the unavailability of a jvm implementation. <br><br>The same was true of <b>perl</b>.

<br><br><b>python</b> was a hot favorite of AppServer folks but did not make the grade because 
it made exchange of simple scripts needlessly difficult <br>(the indentations 
have a way of getting lost when you copy/paste your scripts to or from emails 
or web pages). Its strict philosophy was <br>also a slight turn off.

<br><br><b>groovy</b> was very interesting since it took the pain out of using the java 
libraries but that very same feature worked against it. While it may <br>be very
comfortable to pick up for developers who are used to the java syntax and API,
we were not very sure that the sysadmins were <br>going to do like it. If possible
we wanted to hide the jvm underneath at least for common tasks.

<br><br>The same was true of <b>beanshell</b> too.

<br><br>The <b>javascript</b> offered a better perspective compared to the above two. It also
had the advantage that we were associated with the <br>early javascript 
implementation (when it was the Mocha) and later we had even carried it as a
server side scripting solution. It had a <br>'discover the features as you use' feel 
to it. It was obviously well suited for doing smaller scripts.
    Looking at its large scale features to <br>manage complexity, 
<br>       It had a very open prototype based inheritance which was much easier to use than
many other languages, Allowed <br>all the features of dynamic languages including
redefining the methods and classes at run time, It is very clean, and easy to 
maintain. <br>       It even allows continuations to be stored and used.

JavaScript was in consideration until the last moment, and so was Ruby.

<br><br>Looking at <b>ruby</b>, There are immediate benefits arising out of its support of open 
classes just like javascript, and interesting abstractions <br>like co-routines, 
interesting uses of objects and iterators, mixins etc. <br>       It also has a very clean 
and consistent syntax. Stitching up small languages for use in configurations and
other server farm administration <br>tasks are also pretty easy in this ruby.

<b><br><br>jscheme</b> was also ruled out as it was markedly different from the shell/perl
world that our end users are in currently.

<br><br>Then we evaluated <b>jacl</b> (TCL), some of the things that we immediately attracted us were,
<br>        1) It had the closest to the shell syntax that we can find on top of a jvm.

<br>        2) Language with the fewest number of rules (right there with scheme) It has a
simple primitive, the command. no special cases <br>             any where, and another simple
data structure the list.

<br>        3) Very high redesign capabilities (You can create your own language with it)
   Macros if you need them, create your own <br>             primitives, redefine syntax etc.

<br>        4) Interesting and few primitives (even lower than scheme) means you can pick 
    it up in half an hour.

<br>        5) max late binding to be found any where.

<br>        6) Availability of an existing vm based language so that we can utilize java 
    api's in a pinch.

<br>        7) an existing event driven model that may come in handy

<br>        8) clean code with consistent interface.

<br><br>While comparing with the rest of the finalist languages, Ruby and JavaScript,
The negatives with TCL <br>(as far as we were concerned) were
    <br><br>1) Richness of syntax. <br>           Ruby has a much richer syntax than either JavaScript
       or TCL, though we were not sure if it should be considered a virtue
       <br>           for the audience we were targeting.
    
    <br>2) No built in OO, but this could be rectified the same way it is done in 
       CommonLisp/Scheme if necessary, since the language <br>           allows itself 
       to be extended quite heavily (incrTcl being an example).

    <br>3) Absence of interesting things like closures, continuations etc. (These
       cant be done in tcl even by extending it, while both ruby <br>           and javascript
       provided them)

<br><br>Considering all the three, the main deficiency was 3, but considering other 
advantages, we decided to go for TCL <br>(or jacl - its jvm implementation.)

the clinching argument was that the command lines would look exactly same in a
stand alone <br>mode and within the jacl environment.<br><br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/using_wadm_in_sjswebserver_7">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
