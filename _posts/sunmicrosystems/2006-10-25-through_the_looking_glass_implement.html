---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
---
{% raw %}
<div class="entry" id="through_the_looking_glass_implement">

	<h3 class="entry-title">
			Through the looking glass: implement extensions for wadm -Sun Java System Web Server 7.0 (part VIII)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 25, 2006</a>
</h4>

    <div class="entry-body">
                                        	
In one of the last sections, We explored the java commands that were available <br>
from the wadm but that is not all. <br>
If necessary we can interface java to wadm by making available the java libraries<br>
as commands. In this section I will take you through implementing an extension <br>
command for wadm (jacl).<br>
<br>
We need to implement two classes. <br>
       1) The extension that will create the command(s) when it is loaded,<br>
       2) The command class itself.<br>
<br>
<h3>First Try</h3>
<font style="color: rgb(204, 0, 0);" size="2">========================================<br>package blue;<br>import tcl.lang.Interp;<br>import tcl.lang.Extension;<br><br>public class MyExtension extends Extension {<br>    public void init(Interp interp) {<br>        interp.createCommand(MyCmd.name, new MyCmd());<br>    }<br>}<br>========================================<br>package blue;<br>import tcl.lang.\*;<br>import java.io.\*;<br>import java.util.\*;<br><br>public class MyCmd implements tcl.lang.Command {<br>    public static String name = "my-cmd"<br>    public void cmdProc(Interp interp, TclObject argv[]) throws TclException {<br>        try {<br>            System.out.println(name + ":Here I am");<br>        } catch(Exception e){<br>            throw new TclException(interp, e.getMessage());<br>        }<br>    }<br>}<br>========================================</font><br>
<br>
Compiling it,<br>
<span style="color: rgb(51, 51, 255);">|export CLASSPATH=$CLASSPATH:&lt;wsroot&gt;/lib/wadmcli.jar</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|export CLASSPATH=$CLASSPATH:&lt;wsroot&gt;/lib/jacl.jar</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|export CLASSPATH=$CLASSPATH:&lt;wsroot&gt;/lib/tcljava.jar</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|export CLASSPATH=$CLASSPATH:&lt;wsroot&gt;/lib/cli-framework.jar</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|javac -d \*.java</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|jar -cf blue.jar blue</span><br style="color: rgb(51, 51, 255);">
<br>
<br>
Let us startup wadm and check them out.<br>
(Assuming that you are starting wadm from the current directory. Other wise change the -classpath to point to blue.jar)<br>
<span style="color: rgb(51, 51, 255);">|java::load -classpath blue.jar blue.MyExtension</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(51, 51, 255);">|my-cmd</span><br style="color: rgb(51, 51, 255);">
<span style="font-style: italic;">my-cmd :Here I am</span><br>
<br>
<br>So we will be able to make a simple wadm shell command, but compared to<br>other wadm commands it has two major defects.<br><br>      1) It does  not have auto completion.<br>                  I am not going to explain it here since it is not one of the published interfaces<br>                  but as a hint..<br>                  We are using the <a href="http://www.glassfishwiki.org/gfwiki/attach/GlassFishAdminReferences/s1as8_cli_framework_cookbook.html" target="_self">glassfish</a> for the command ,option parsing and Using a file<br>                  similar to CLI Descriptor can be found in the jars. The auto completion is also <br>                  done using the same file. So you can extract the the file from jar, put your <br>                  commands in (as described in the above link) and repackage it, and autocomplete<br>                  for command and its options should work fine.<br>        2) It does not work in stand alone mode.<br>                 The above hint works here too. You can define your own command by deriving it<br>                 from the <a href="http://appserver.sfbay.sun.com/apollo/cli/api/framework/" target="_self">Command</a> and you can add it to our descriptor file. If you are going this<br>                 way, then you can change the wadm[sh|bat] to load your jar file too.<br><br><br>
Well that seems to have worked. Let us add a little more, say argument processing and see.<br><br><h4>Argument Processing</h4>The jacl gives us all the arguments in the 'TclObject argv[]' variable that is passed in<br>the format of the argv is similar to java :argv[0] = command name and argv[&gt;0] the rest of arguments. <br><br>
<font style="color: rgb(204, 0, 0);" size="2">========================================</font><br style="color: rgb(204, 0, 0);">
<font style="color: rgb(204, 0, 0);" size="2">package blue;<br>import tcl.lang.\*;<br>import java.io.\*;<br>import java.util.\*;<br><br>public class MyCmd implements tcl.lang.Command {<br>    public static String name = "my-cmd";<br>    public void cmdProc(Interp interp, TclObject argv[]) throws TclException {<br>        StringBuffer sb = new StringBuffer();<br>        try {<br>            for (Object o: argv) {<br>                sb.append(":"+o);<br>            }<br>            System.out.println(name + sb);<br>        } catch(Exception e){<br>            throw new TclException(interp, e.getMessage());<br>        }<br>    }<br>}<br></font><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br style="color: rgb(204, 0, 0);"><h4>
Using It</h4>
<span style="color: rgb(51, 51, 255);">|java::load -classpath blue.jar blue.MyExtension<br>|my-cmd abc def g<br></span><span style="color: rgb(0, 0, 0); font-style: italic;">my-cmd:my-cmd:abc:def:g</span><br style="color: rgb(51, 51, 255);">
<span style="color: rgb(0, 0, 0); font-style: italic;"><br></span><span style="color: rgb(0, 0, 0);">To avoid the manual loading every time, let it add it to .wadmrc</span><span style="color: rgb(0, 0, 0); font-style: italic;"><br></span><font style="color: rgb(204, 0, 0);" size="2">================.wadmrc==================</font><font size="2"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">catch {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">package require java</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">java::load -classpath "blue.jar" blue.MyExtension</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);">} err</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">puts $err</span><br style="color: rgb(204, 0, 0);"></font><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================</span><br style="color: rgb(204, 0, 0);"><br></span></font><span style="color: rgb(51, 51, 255);"></span>When dealing with java and especially in .wadmrc, it is always a nice thing to wrap <br>your loading in catch block. Other wise the only sign of an error or an exception will<br>be 'Invalid RC File' printed on your console when you invoke the wadm.<br><br><h4>Strings and Lists</h4>Your commands can take both Strings and lists. <br>(The strings are same as lists in tcl, a multivalue list is nothing but a string with spaces in <br>them which also means that a word is a single value list.)<br><br>It depends on the command to distinguish as to what was passed in was a String, a List <br>or a number(int/real). You can get the string representation of the argument by just doing<br>a argv[xxx].toString. If a list was passed in, then you will get the list in tcl representation<br>ie:<br><span style="color: rgb(51, 51, 255);">|my-cmd a b c    </span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:a:b:c</span></font><br><span style="color: rgb(51, 51, 255);">|my-cmd {a b c}</span><br><font style="font-style: italic;" size="2">my-cmd:my-cmd:a b c</font><br><span style="color: rgb(51, 51, 255);">|my-cmd {a b c} {d e f}</span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:a b c:d e f</span></font><br><span style="color: rgb(51, 51, 255);">|my-cmd {a {b c}} {d e f}</span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:a {b c}:d e f</span></font><br><br>The strings that get passed in can be any thing..<br><br><span style="color: rgb(51, 51, 255);">|my-cmd --name mexico -p 8080 newmexico</span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:--name:mexico:-p:8080:newmexico</span></font><br><br>You can use a library like getopt to parse these. (Or make use of the bundled glassfish <br>cli-framework to do it for you.)<br><br><h4>Returning Values</h4>    Often times you are interested in the return values of the command you ran. Let us<br>see how our newly implemented command fares<br><br><span style="color: rgb(51, 51, 255);">|set out [my-cmd --name mexico -p 8080 newmexico]</span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:--name:mexico:-p:8080:newmexico</span></font><br><span style="color: rgb(51, 51, 255);">|puts $out</span><br><br><span style="color: rgb(51, 51, 255);">|</span><br>Unfortunately it does not work. In order for the tcl to receive a value, it has to be <br>passed in another fashion. There are different ways for things that contain just one<br>element and things that return multi element lists.<br><br>        <span style="font-weight: bold;">Strings</span><br>For strings we just set the result string into the interpretor as shown below,<br><br><font style="color: rgb(204, 0, 0);" size="2">========================================</font><br><font size="2"><span style="color: rgb(204, 0, 0);">package blue;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import tcl.lang.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.io.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.util.\*;</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">public class MyCmd implements tcl.lang.Command {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public static String name = "my-cmd";</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public void cmdProc(Interp interp, TclObject argv[]) throws TclException {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        StringBuffer sb = new StringBuffer();</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        try {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            for (Object o: argv) {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">                sb.append(":"+o);</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            interp.setResult(name + sb);</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        } catch(Exception e){</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            throw new TclException(interp, e.getMessage());</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span><br style="color: rgb(255, 0, 0);"></font><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================<br><br></span></span></font><span style="color: rgb(51, 51, 255);">|set out [my-cmd --name mexico -p 8080 newmexico]</span><br><font style="font-style: italic;" size="2">my-cmd:my-cmd:--name:mexico:-p:8080:newmexico</font><br><span style="color: rgb(51, 51, 255);">|puts $out</span><br><font size="2"><span style="font-style: italic;">my-cmd:my-cmd:--name:mexico:-p:8080:newmexico</span></font><br><br><br>        <span style="font-weight: bold;">Lists</span><br>
<br>For producing tcl lists, you have to instanciate TclList instance and keep appending<br>the elements to it, then return its stirng representation in the interp.<br><br><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================</span></span></font><br><font size="2"><span style="color: rgb(204, 0, 0);">package blue;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import tcl.lang.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.io.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.util.\*;</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">public class MyCmd implements tcl.lang.Command {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public static String name = "my-cmd";</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public void cmdProc(Interp interp, TclObject argv[]) throws TclException {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        TclObject obj =  TclList.newInstance();</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        try {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            for (Object o: argv) {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">                TclList.append(interp, obj, </span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">                    TclString.newInstance(o.toString()));</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            interp.setResult(obj.toString());</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        } catch(Exception e){</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            throw new TclException(interp, e.getMessage());</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span><br style="color: rgb(204, 0, 0);"></font><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================<br><br></span></span></font><span style="color: rgb(51, 51, 255);">|set out [my-cmd --name mexico -p 8080 newmexico]      </span><br><font size="2"><span style="font-style: italic;">my-cmd --name mexico -p 8080 newmexico</span></font><br><span style="color: rgb(51, 51, 255);">|puts $out</span><br><font size="2"><span style="font-style: italic;">my-cmd --name mexico -p 8080 newmexico</span></font><br><br><span style="color: rgb(51, 51, 255);">|set out [my-cmd --name "My mexico" -p 8080 newmexico]</span><br><font size="2"><span style="font-style: italic;">my-cmd --name {My mexico} -p 8080 newmexico</span></font><br><span style="color: rgb(51, 51, 255);">|puts $out                                            </span><br><font style="font-style: italic;" size="2">my-cmd --name {My mexico} -p 8080 newmexico</font><br><br>You can see the difference here.<br><br>
<span style="font-weight: bold;">Handling Errors</span><br>        

For robust implementations, you also need to let the tcl know about<br>any errors in the execution (That includes validation errors and process errors)<br>In wadm, you can do that by throwing a TclException when you encounter <br>such a problem,<br>

<br><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================</span></span></font><font size="2"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">

package blue;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import tcl.lang.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.io.\*;</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">import java.util.\*;</span><br style="color: rgb(204, 0, 0);"><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">public class MyCmd implements tcl.lang.Command {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public static String name = "my-cmd";</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    public void cmdProc(Interp interp, TclObject argv[]) throws TclException {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        if (argv.length == 1)</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            throw new TclException(interp,"Need at least 1 argument");</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        TclObject obj =  TclList.newInstance();</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        try {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            for (Object o: argv) {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">                TclList.append(interp, obj,</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">                    TclString.newInstance(o.toString()));</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            interp.setResult(obj.toString());</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        } catch(Exception e){</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            throw new TclException(interp, e.getMessage());</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">        }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span></font><br><font style="color: rgb(204, 0, 0);" size="2"><span style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">========================================</span></span></font><br><br><span style="color: rgb(51, 51, 255);">|my-cmd   </span><br><font size="2"><span style="font-style: italic;">Need at least 1 argument</span></font><br><span style="color: rgb(51, 51, 255);">|if [catch {my-cmd} err] {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      puts "-- $err"</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br><font size="2"><span style="font-style: italic;">-- Need at least 1 argument</span></font><br><span style="color: rgb(51, 51, 255);">|      </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|if [catch {my-cmd -one} err] {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      puts "-- $err"</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br><br>As you see no error was thrown when passing an option. The error is<br>caught by tcl when the problematic statement or script is enclosed in a<br>"catch {....} err"  block<br><br>You can use these as a template for your work.<br><a href="../../blue/resource/MyCmd.java" target="_self">MyCmd.java</a><br><a href="../../blue/resource/MyExtension.java" target="_self">MyExtension.java</a><br><br>

--removing auto completion since that is not a published interface.<br>

but a hint, We are using the <a href="http://www.glassfishwiki.org/gfwiki/attach/GlassFishAdminReferences/s1as8_cli_framework_cookbook.html" target="_self">glassfish</a> for the command ,option parsing and Using a file<br>

similar to CLI Descriptor can be found in the jars. The auto completion is also done using<br>

the same file.<br>

<br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/through_the_looking_glass_implement">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
