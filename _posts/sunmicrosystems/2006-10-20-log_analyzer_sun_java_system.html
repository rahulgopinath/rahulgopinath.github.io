---
layout: post
categories : sunblog
tagline: "."
tags : [sunmicrosystems blog sun]
e: Log Analyzer for  Sun Java System Web Server 7.0 wadm scripting (part IV)
---
{% raw %}
<div class="entry" id="log_analyzer_sun_java_system">

	<h3 class="entry-title">
			Log Analyzer for  Sun Java System Web Server 7.0 wadm scripting (part IV)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 20, 2006</a>
</h4>

    <div class="entry-body">
                                        	
   In the earlier section, we looked at how to create a parser by defining a little language that understood what <br>we were trying to parse, here we will try an create a little language that _we_ can use to look at the data in a <br>more comprehensive way.<br><br>One of the more interesting things that the Web Server provides is the access logs that tells us who are visiting <br>our site, how many pages they visited, who are all referring to us, and how many (if any) pages have broken <br>links (ie how many 404 we have.)<br><br>Interesting info also includes the type of UserAgents, the pages that seem to get hit the largest, and our entry <br>points, (The pages that a unique ip will have accessed first,) our exit points (The page which the unique ips <br>accessed last) etc.<br><br><span style="color: rgb(204, 0, 0); font-weight: bold;">Assume the wadm prompt is "|" so that </span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">|puts new</span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">is the wadm command "puts new"</span><br><h4>The commands that wadm provides for logs:</h4>
<span style="color: rgb(51, 51, 255);">|info commands \*log\*</span><br><span style="font-style: italic;">get-log enable-access-log set-log-prop get-access-log get-access-log-prop get-log-prop <br>set-access-log-buffer-prop rotate-log get-access-log-buffer-prop disable-access-log</span><br style="font-style: italic;"><br>While the wadm does provide a means for us to get the access log as a whole, they are not meant to be <br>used directly. (ie they just dump the whole information as a chunk with out any way to filter the information to <br>what is relevant for us)<br><br>But this is not a very serious handicap as long as we have the scripting ability. Infact it provides us freedom <br>to define the interface that we like to to access the data which we are interested in.<br><br><h3>Substructure: Access Log from wadm<br>
</h3>
<span style="color: rgb(51, 51, 255);">|get-access-log --config=test agneyam</span><br><span style="font-style: italic;">format=%Ses-&gt;client.ip% - %Req-&gt;vars.auth-user% [%SYSDATE%] "%Req-&gt;reqpb.clf-request%" <br>%Req-&gt;srvhdrs.clf-status% %Req-&gt;srvhdrs.content-length%</span><br style="font-style: italic;"><span style="font-style: italic;">webcache.sun.com - - [20/Oct/2006:06:27:57 -0700] "GET / HTTP/1.1" 200 355</span><br style="font-style: italic;"><span style="font-style: italic;">webcache.sun.com - - [20/Oct/2006:06:27:58 -0700] "GET /favicon.ico HTTP/1.1" 200 3574</span><br style="font-style: italic;"><span style="font-style: italic;">webcache.sun.com - - [20/Oct/2006:06:28:03 -0700] "POST /cgi-bin/test-cgi HTTP/1.1" 200 596</span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com - - [20/Oct/2006:06:28:22 -0700] "GET / HTTP/1.1" 200 355</span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com - - [20/Oct/2006:06:28:22 -0700] "GET /favicon.ico HTTP/1.1" 200 3574</span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com - - [20/Oct/2006:06:28:24 -0700] "POST /cgi-bin/test-cgi HTTP/1.1" 200 602</span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com - - [20/Oct/2006:06:28:48 -0700] "GET /cgi-bin/test-cgi?myvar=new HTTP/1.1" 200 573</span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com - - [20/Oct/2006:06:29:06 -0700] "GET /whoami.html HTTP/1.1" 404 292</span><br><span style="font-style: italic;">hokus-pokus.sun.com - - [20/Oct/2006:23:09:15 +0530] "GET / HTTP/1.1" 200 355</span><br><br>(You can also modify the settings of access log by using the following CLIs)<br><span style="color: rgb(51, 51, 255);">|get-access-log-prop  --config=test</span><br><span style="font-style: italic;">enabled=true</span><br style="font-style: italic;"><span style="font-style: italic;">file=../logs/access</span><br style="font-style: italic;"><span style="font-style: italic;">format=%Ses-&gt;client.ip% - %Req-&gt;vars.auth-user% [%SYSDATE%] "%Req-&gt;reqpb.clf-request%" <br>%Req-&gt;srvhdrs.clf-status% %Req-&gt;srvhdrs.content-length%<br><br>#assuming your new custom format is in the variable $myformat<br></span><span style="color: rgb(51, 51, 255);">|set-access-log-prop --config=test format=$myformat</span><br><br><h3>Choosing a superstructure</h3>The access log is a matrix that is arranged cronologically. The SQL (Structured Query Language) is generally <br>useful in mining data out of these matrices. More so because the users will be able to transpose at least a part <br>of their familiarity with SQL to our API.<br><br>While it is useful to stick close to SQL, I am changing it slightly so as to make it easier to parse. In general <br>this is what I am going to do:<br><h4>Syntax</h4>
<span style="color: rgb(255, 102, 0);">select {select list} from {from list} where {where list} group by {id}</span><br><br>The where part and later are optional.<br>Each of the key words are followed by a list which specifies the list associated with it. The list will contain <br>the variables that will be extracted from the logs.<br><h4>Some UseCases</h4>
<span style="color: rgb(153, 153, 153);">#select {\*} from machine1</span><br style="color: rgb(153, 153, 153);"><span style="color: rgb(153, 153, 153);">#Avoiding this common use case for now to make the code a little more simpler<br>#The reason for choosing $xxx is that we will be able to replace them with the corresponding<br>#values just by evaluating them. This will make it much simpler to construct the result.<br></span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">select {$ip,$request,$response} from machine1</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">select {$ip,$</span><span style="color: rgb(255, 102, 0);">request</span><span style="color: rgb(255, 102, 0);">,$response} from {machine1,machine2}</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">select {$ip,$</span><span style="color: rgb(255, 102, 0);">request</span><span style="color: rgb(255, 102, 0);">,$response} from machine1 where {$response == 404}</span><br style="color: rgb(255, 102, 0);">
<span style="color: rgb(255, 102, 0);">select {$ip</span><span style="color: rgb(255, 102, 0);"> [:sum $size] } from machine1 where {$response == 404} group by {$ip}<br><br></span><h4>More assumptions and short cuts (In the interest of simplicity)<br>
</h4>While it is easy to parse the format line from <span style="font-style: italic; font-weight: bold;">get-access-log-prop</span><br>
<span style="font-style: italic;">format=%Ses-&gt;client.ip% -
%Req-&gt;vars.auth-user% [%SYSDATE%] "%Req-&gt;reqpb.clf-request%"
%Req-&gt;srvhdrs.clf-status% %Req-&gt;srvhdrs.content-length%<br></span>We wont be parsing that, Instead we will use fixed positions for now.<br><br>ie: from the above<br><span style="color: rgb(255, 102, 0);">$ip : 0</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">#dummy field -</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">$auth : 2</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">$date : 3</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">#you can always massage the data to remove the _"_ from request and you will get the $method, $uri, $http from the $request.</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">$request : 5</span><br style="color: rgb(255, 102, 0);"><span style="color: rgb(255, 102, 0);">$response : 6</span><br style="color: rgb(255, 102, 0);">
<span style="color: rgb(255, 102, 0);">$size : 7</span><br style="color: rgb(255, 102, 0);"><h3>Implementing the Language</h3>As always it is a good idea to start with a namespace.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">=================db.tcl===============</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">namespace eval Logs {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    namespace export {select}</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc select args {</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">            puts "&gt;$args"</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    }</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">}</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">====================================</span></font><br style="color: rgb(204, 0, 0);"><br>Remember what we discussed last section? The args is the variable args mechanism for tcl. <br>so any tcl statement that takes args as a parameter will take any number of parameters. With <br>that in mind, the proc select will be able to slurp the entire query that we will throw at it.<br><br>
The namespace export marks for export the procedures that we want others to be able to <br>use natively. ie by using<br><br><span style="color: rgb(51, 51, 255);">|namespace import Logs::select<br><br></span>from global namespace, the user will be able to make use of our language with out polluting his <br>namespace with our local procedurs.<br><h4>The select statement.</h4>
<font size="2"><span style="color: rgb(204, 0, 0);">==================================</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    proc select args {<br>        set select {}<br>        set from {}<br>        set where {}<br>        set group {}<br>        set group_by {}<br>        set lastword select<br>        foreach word $args {<br>            #look for our delimiters<br>            switch $word {<br>                from {<br>                    set lastword from<br>                }<br>                where {<br>                    set lastword where<br>                }<br>                group {<br>                    set lastword group<br>                }<br>                by {<br>                    set lastword group_by<br>                }<br>                default {<br>                    lappend $lastword $word<br>                }<br>            }   <br>        }   <br>        exec_select [join $select { }] [join $from { }] [join $where { }] [join $group_by {}]<br>    }<br></span><span style="color: rgb(204, 0, 0);">==================================<br></span></font>What we are doing here, is to take an easy way.  We are just looking for the keywords 'from' 'where' <br>and 'group' to extract the lists following them, we use the tcl's dynamic nature to just change the variable <br>being appended to. <br><br>You would have under stood the reason whey we went for a {$ip $response} model rather than simply <br>$ip $response in the select statement,...   <br>          The reason is that if we had gone for $ip $response model, tcl would have evaluated them in the <br>execution local context rather than wait for us to supply them. the braces {} provides us a convenient <br>bubble to protect against evaluation before time.<br><br>check it out with the exec_select<br><font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br><font style="color: rgb(204, 0, 0);" size="2">
    proc exec_select {select from where group} {<br>
        puts "-------------"<br>
        puts "select&gt;"<br>
        puts $select<br>
        puts "from&gt;"<br>
        puts $from<br>
        puts "where&gt;"<br>
        puts $where<br>
        puts "group_by&gt;"<br>
        puts $group<br>
        puts "-------------"<br>
   }<br></font>
<font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br>
<span style="color: rgb(51, 51, 255);">|select {$ip -&gt; $response} from agneyam where {$response == 404}</span><br><span style="font-style: italic;">-------------</span><br style="font-style: italic;"><span style="font-style: italic;">select&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">$ip -&gt; $response</span><br style="font-style: italic;"><span style="font-style: italic;">from&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">agneyam</span><br style="font-style: italic;"><span style="font-style: italic;">where&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">$response == 404</span><br style="font-style: italic;"><span style="font-style: italic;">group_by&gt;</span><br><br>Using the $select list as an output formater, and $where as the condition.<br>Here is what the exec select would look like.<br><font size="2"><span style="color: rgb(204, 0, 0);"></span></font><br><font size="2"><span style="color: rgb(204, 0, 0);">================================================<br>    proc exec_select {select from where group} {<br>        set collect 0<br>        #check if we have grouping statements in select (:sum)<br>        #<br>        # if there are, then we use the current select statement as a template for two types of statements<br>        # one to keep adding to an accumulator each variable that is grouped, and the other template to<br>        # fetch all the data at the end of the loop from the accumulator and construct the result.<br>        # if there are none, then we just have one template which will contain the variables that will be<br>        # expanded inline at the end of each iteration.<br><br>        #use_select and collect_select are the two templates. use_select sends data to accumulator and<br>        #collect_select retrieves them.<br><br>        if {[regexp {:[a-zA-Z]+} $select]} then {<br>            set collect 1<br>            regsub -nocase -all {:([a-zA-Z]+) } $select {use_\\1 [incr use_id]:$id } use_select<br>            regsub -nocase -all {:([a-zA-Z]+) } $select {collect_\\1 [incr use_id]:$id } collect_select<br>        } else {<br>             set use_select $select<br>        }<br><br>        #process the from here. <br>        #interleave-logs will collect all the logs from the list of machines supplied and splat it into a list.<br>        set cmd {[interleave-logs $from]}<br>        set all_logs [subst $cmd]<br>        foreach line $all_logs {<br>            set use_id 0<br>            set id [subst_in_context $line $group]<br>            if {[expr [string length $where] &gt; 0]} {<br>                if [expr $where] {<br>                    eval_select $line $use_select<br>                }<br>            } else {<br>                eval_select $line $use_select<br>            }<br><br>        }<br>        if $collect {<br>            foreach id [array names Logs::context] {<br>                set line $Logs::context($id)<br>                set use_id 0<br>                puts [subst_in_context $line $collect_select]<br>                unset Logs::context($id)<br>            }<br>        }<br>    }<br></span><span style="color: rgb(204, 0, 0);"></span></font><font size="2"><span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);">================================================</span><br style="color: rgb(204, 0, 0);"></font><br>Interleave logs is a tiny procedure that mixes the logs from multiple machines.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">================================================<br>    proc interleave-logs {args} {<br>        set fmt [Date::GetFormat]<br>        Date::SetFormat {\\[DD/MMM/YYYY:T24S}<br>        set logs {}<br>        foreach machine $args {<br>            set log [get-log $machine]<br>            set logs [concat $logs $log]<br>        }<br>        set sorted [lsort -command compare-dates $logs]<br>        Date::SetFormat $fmt<br>        return $sorted<br>    }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br><br>the accumulator is pretty simple.<br><font size="2"><span style="color: rgb(204, 0, 0);">================================================<br>    proc use_sum {_id val} {<br>        upvar 1 ip ip<br>        upvar 1 auth auth<br>        upvar 1 date date<br>        upvar 1 request request<br>        upvar 1 response response<br>        set id [subst $_id]<br>        if [info exists Logs::results($id)] {<br>            array set Logs::results [list $id "$Logs::results($id) $val"]<br>        } else {<br>            array set Logs::results [list $id "$val"]<br>        }<br>        return $val<br>    }<br>    proc collect_sum {_id val} {<br>        upvar 1 ip ip<br>        upvar 1 auth auth<br>        upvar 1 date date<br>        upvar 1 request request<br>        upvar 1 response response<br>        upvar 1 size size <br>        set id [subst $_id]<br>        set lst $Logs::results($id)<br>        set sum 0<br>        foreach l $lst {<br>            set sum [expr $sum + $l]<br>        }<br>        set Logs::results($id) {}<br>        return $sum<br>    }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br><br>To define any new [:xxx ] procedure that you want to apply in select procedure, you just have to <br>copy the previous procedures, define the use_xx and collect_xxx, and change the list processing in <br>collect_xxx accourdingly (as given below.)<br><font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br><font style="color: rgb(204, 0, 0);" size="2">        set sum<br></font><font style="color: rgb(204, 0, 0);" size="2">        foreach l $lst {<br>            set sum [your_func $sum $l]<br>        }<br></font><font size="2"><span style="color: rgb(204, 0, 0);">================================================</span></font><br>As you would have noticed there is some redundancy which can be
eliminated. but this form is <br>easier to understand than after eliminating the common portion.<br><br><span style="font-weight: bold;"><br></span>The complete db.tcl is available <a href="../../blue/resource/db.tcl" target="_self">here</a>.<font style="color: rgb(204, 0, 0);" size="2"></font><h3>Using it</h3>
<span style="color: rgb(51, 51, 255);"></span>1) Make sure that the date.tcl from the below section is in your current directory along with db.tcl<br><br><span style="color: rgb(51, 51, 255);">|source db.tcl<br><span style="color: rgb(51, 51, 255);"></span>|select {$ip, $request, $response } from agneyam</span><br><span style="font-style: italic;">webcache.sun.com, GET /favicon.ico HTTP/1.1, 200 </span><br style="font-style: italic;"><span style="font-style: italic;">webcache.sun.com, POST /cgi-bin/test-cgi HTTP/1.1, 200 </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, GET /favicon.ico HTTP/1.1, 200  </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, GET / HTTP/1.1, 200  </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, POST /cgi-bin/test-cgi HTTP/1.1, 200  </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, GET /cgi-bin/test-cgi?myvar=new HTTP/1.1, 200  </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, GET /whoami.html HTTP/1.1, 404  </span><br style="font-style: italic;"><span style="font-style: italic;">varunam.sun.com, GET /mexico.html HTTP/1.1, 404  <br>hokus-pokus.sun.com, GET / HTTP/1.1, 200<br><br></span><span style="color: rgb(51, 51, 255);">|select {$ip, $request, $response } from agneyam where {$response == 404}</span><span style="font-style: italic;"><br>varunam.sun.com, GET /whoami.html HTTP/1.1, 404 <br>varunam.sun.com, GET /mexico.html HTTP/1.1, 404 <br><br></span><span style="color: rgb(51, 51, 255);">|select {$ip [:sum $size] } from agneyam group by {$ip}</span><span style="font-style: italic;"><br>hokus-pokus.sun.com 355 <br>varunam.sun.com 5688 <br>webcache.sun.com 4170 <br><br></span><span style="color: rgb(51, 51, 255);">|select {$response [:sum $size] } from agneyam group by {$response}</span><span style="font-style: italic;"><br>404 584 <br>200  9629 <br><br></span><span style="color: rgb(51, 51, 255);">|select {$ip [:sum 1] } from agneyam group by {$ip}                   </span><span style="font-style: italic;"><br>hokus-pokus.sun.com 1 <br>varunam.sun.com 6 <br>webcache.sun.com 2 <br>                                                                      <br></span><span style="color: rgb(51, 51, 255);">|select {$response [:sum 1] } from agneyam group by {$response}</span><span style="font-style: italic;"><br>404 2 <br>200 7 <br></span><h4>required utilities: </h4>date.tcl from <a href="../../blue/resource/date.tcl" target="_self">here</a> or <a href="http://web.uvic.ca/%7Eerempel/tcl/DatePkg/DatePkg.html" target="_self">here(external)</a><br><span style="color: rgb(0, 102, 0);">       [download the sourcefile and save it as date.tcl. </span><br style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 102, 0);">             use the below command to use it before you source the db.tcl (It is already sourced in db.tcl)</span><br style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 102, 0);">             <span style="font-weight: bold;">|source date.tcl</span></span><br style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 102, 0);">      ]<br></span>The complete db.tcl is available <a href="../../blue/resource/db.tcl" target="_self">here</a>.<br style="color: rgb(0, 102, 0);">

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/log_analyzer_sun_java_system">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
