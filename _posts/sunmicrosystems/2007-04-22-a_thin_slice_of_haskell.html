---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
---
{% raw %}
<div class="entry" id="a_thin_slice_of_haskell">

	<h3 class="entry-title">
			A thin slice of Haskell
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Apr 22, 2007</a>
</h4>

    <div class="entry-body">
                                        	<p>These are notes on functional programming language Haskell some what tidied up to be presentable. I had made these as I was studying the language. (done using <a title="Haskell interpretor" href="http://www.haskell.org/hugs/">Hugs</a>. )</p>
<p>Haskell is one of the better known functional languages in use. It is purely functional and follows the lambda calculus closely. While it is not homoiconic, it is one of those languages that will change your perspective on programming. </p>
<p>Hugs&gt; :version<br>-- Hugs Version September 2006<br><br></p>
<h4>Some conventions<br>
</h4>
<p>The interactive prompt of Hugs is assumed to be '|', the output from Hugs is shown with a leading '=', :e switches to edit mode (as it does in Hugs) and :t shows the type of the expressions.</p>
<p>The markers '&lt;[ and ]&gt;' denote the source code.</p>
<h4>Arithmetic and Lists<br>
</h4>
<blockquote>|2 + 1<br>=3<br>|length [1,2,3]<br>=3<br>|head [1,2,3]<br>=1<br>
</blockquote>
<h4>Lists creation.</h4>
<p>The arithmetic progression lists are recognized based on the number of elements you provide and the difference between the first and second element. </p>
<blockquote><p>|take 3 [1..10]<br>=[1,2,3]<br>|take 3 [1,4..20]<br>=[1,4,7]<br>|take 3 [10, 9.. 1]<br>=[10,9,8]<br>|take 3 ['a'..'z']<br>=['a','b','c']</p></blockquote>
<p>The lists are lazy (values are computed only when needed), which makes it possible to have infinite sequences.<br></p>
<blockquote>|take 3 [2..]<br>=[2,3,4]<br>|take 3 [1,3..]<br>=[1,3,5]<br>
</blockquote>
<p>Tuples can be used like structures in other languages (mostly).<br></p>
<blockquote>|(2,3)<br>=(2,3)<br>|('a',3,"My name")<br>=('a',3,"My name")</blockquote>
<p><br></p>
<h4>Editing</h4>
<p>use :e to switch between editing modes and :l to load any file (when you exit the editor after :e, the current module is reloaded automatically). The :e will work only if you have the 'EDITOR' variable set.<br><br>|:e My.hs<br></p>
<pre><font face="tahoma,arial,helvetica,sans-serif">&lt;[ My.hs<br></font></pre>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">module My where</font><br><font face="tahoma,arial,helvetica,sans-serif">len [] = 1</font><br><font face="tahoma,arial,helvetica,sans-serif">len (x:xs) = 1 + (len xs)</font><br><p><font face="tahoma,arial,helvetica,sans-serif"></font>-- the obligatory quicksort.<br></p><pre>quicksort [] = []<br>quicksort (s:xs) = quicksort [x|x &lt;- xs,x &lt; s] ++ [s] ++ quicksort [x|x &lt;- xs,x &gt;= s] <br></pre></pre></blockquote>
<pre><font face="tahoma,arial,helvetica,sans-serif">]&gt;</font><br></pre>
<p>|:l My.hs</p>
<p>notes:<br></p>
<ul>
<li>module definition written as -- module &lt;Name&gt; where &lt;definitions&gt;</li>
<li>the nil list can be written as [] and normal lists can be split as (x:xs)</li>
<li>You can specify multiple definitions with different input patterns. The above should be read as, <br>
</li>
<ul>
<li>len is defined as &lt;...&gt; when the input is [] (an empty list)</li>
<li>len is defined as &lt;...&gt; when the input is a list (the empty list is already matched in the previous def, so we get only the non empty ones in the second.)<br>
</li>
</ul>
</ul>
<p> </p>
<h4>A simple definition.</h4>
<p>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">quad a b c = (negb + discr) / (2 \* a)</font><br><font face="tahoma,arial,helvetica,sans-serif">        where</font><br><font face="tahoma,arial,helvetica,sans-serif">            negb = -(b)</font><br><font face="tahoma,arial,helvetica,sans-serif">            discr = sqrt ((b \* b) - 4 \* a \* c)</font></pre></blockquote>
<p>]&gt;<br>|quad 1 30 2<br>=-0.0688<br></p>
<p> </p>
<p>notes:<br>
</p>
<ul>
<li>using where to define local definitions.</li>
<li>parens -- () -- are used for grouping and tuples, not for function argument delimits. Also function arguments are delimited by whitespace.<br>
</li>
</ul>
<h4>Guards.<br>
</h4>
<p>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">fx x y  | y &gt; z = 1</font><br><font face="tahoma,arial,helvetica,sans-serif">          | y == z = 0</font><br><font face="tahoma,arial,helvetica,sans-serif">          | y &lt; z = -1</font><br><font face="tahoma,arial,helvetica,sans-serif">        where z = x \* x</font></pre></blockquote>
<p>]&gt;<br>| fx 1 2<br>=1<br>|fx 4 1<br>=-1<br></p>
<p>notes:<br>
</p>
<ul><li>The '|' are called pattern guards they can be used to provide different implementations for functions based on the value of expressions. They are like the input patterns but are defined with in the function itself and may involve computation.<br>
</li></ul>
<p>some examples.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">max x y</font><br><font face="tahoma,arial,helvetica,sans-serif">    | x &gt; y = x</font><br><font face="tahoma,arial,helvetica,sans-serif">    | otherwise = y</font><br><font face="tahoma,arial,helvetica,sans-serif"><br>fact n | n == 0 = 1</font><br><font face="tahoma,arial,helvetica,sans-serif">         | otherwise = n \* fact (n-1)</font></pre></blockquote>
<p>]&gt;<br>using case instead of guards or input patterns.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">len lst = case lst of</font><br><font face="tahoma,arial,helvetica,sans-serif">        [] -&gt; 0</font><br><font face="tahoma,arial,helvetica,sans-serif">        (x:xs) -&gt; 1 + (len xs)</font></pre></blockquote>
<p>]&gt;<br>case with computable expressions.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">abs x = case x of<br>        x | x &gt;= 0 -&gt; x<br>          | x &lt; 0 -&gt; -x<br></font></pre></blockquote>
<p>]&gt;</p>
<p>destructuring a list using bind pattern<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">(x:y:z:rest) = [1..]</font></pre></blockquote>
<p>]&gt;<br>|x<br>=1<br>|y<br>=2<br><br></p>
<h4>List comprehensions<br>
</h4>
<p> </p>
<p> Generators</p>
<blockquote>|[1..3]<br>=[1,2,3]<br><br>|[(x,y) | x &lt;- [1..3], y &lt;- [3,2..1]]<br>=[(1,3),(1,2),(1,1),(2,3),(2,2),(2,1),(3,3),(3,2),(3,1)]<br><br>|[(x,y) | x &lt;- [1..3], y&lt;- "ab"]<br>=[(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]<br><br>|[x\*x | x &lt;- [1..3]]<br>=[1,4,9]<br><br>
</blockquote>
<p>Filters </p>
<p>   Filters are created by following a generator with a filtering function<br></p>
<blockquote>|[ x | x &lt;- [1..4], even x]<br>=[2,4]<br><br>|[ (x,y) | x &lt;- [1..4], even x, y &lt;- "ab" ]<br>=[(2,'a'),(2,'b'),(4,'a'),(4,'b')]<br>
</blockquote>
<p> </p>
<p>map and filter using list comprehensions.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">map f  xs = [ f x | x &lt;- xs ]</font><br><font face="tahoma,arial,helvetica,sans-serif">filter p xs = [ x | x &lt;- xs, p x ]</font></pre></blockquote>
<p>]&gt;<br></p>
<p><br></p>
<h4>Using Let</h4>
<p>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">sum ys = <br>  let sumlocal [] total = total<br>      sumlocal (x:xs) total = sumlocal xs (total+x)<br>  in sumlocal ys 0<br></font></pre></blockquote>
<p>]&gt;<br></p>
<p>notes:<br>
</p>
<ul>
<li>let allows creation of  inner functions.</li>
<li>the syntax is let &lt;...&gt; in &lt;expression&gt; <br>
</li>
</ul>
<p><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">roots a b c =<br>    let det = sqrt (b\*b - 4\*a\*c)<br>        a2 = 2\*a<br>    in ((-b + det) / a2,<br>         (-b - det) / a2)</font><br></pre></blockquote>
<p>]&gt;<br>|roots 1 30 2<br>(-0.0668,-29.9331)<br><br><br>Unwrapping tuples<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">unzip ((a, b):rest) = <br>  let (as, bs) = unzip rest <br>  in (a:as, b:bs)<br></font></pre></blockquote>
<p>]&gt;<br><br><br>Tuples again<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">distance (x1,y1) (x2,y2) = sqrt (dx\^2 + dy\^2)<br>    where<br>        dx = x2 - x1<br>        dy = y2 - y1</font></pre></blockquote>
<p>]&gt;<br><br>|distance (1,2) (3,4)<br>=2.828</p>
<p>:t distance<br>=distance :: Floating a =&gt; (a,a) -&gt; (a,a) -&gt; a<br></p>
<p>notes:<br>
</p>
<ul>
<li>The tuples are an aggregate datatype composed by enclosing the values in parens-- ()<br>
</li>
<li>we pass two tuples (1,2) and (3,4) to distance function. <br>
</li>
<li>As you can see in :t distance, the type of tuple is (a,a)<br>
</li>
</ul>
<p><br></p>
<h4>Monads<br>
</h4>
<p>Monads are a way to encode sequential (or state) information in the programs (There are many other ways of looking at the monads, but this seems to be the simplest.) <br></p>
<p>IO monad.<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">main = do<br>    putStr "hello"<br></font></pre></blockquote>
<p>]&gt;<br><br>|main<br>=hello<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">main = do<br>    putStr "Name? "<br>    x &lt;- getLine<br>    putStr . concat $ ["Hello[", x, "]"]</font></pre></blockquote>
<p>]&gt;<br></p>
<p>notes:<br>
</p>
<ul>
<li>The do notation with the funny &lt;- that looks like assignment is actually just syntax sugar for a higher operation called bind. I will not be treating that part here.</li>
<li>be careful of the indentation. the first statement after do determines the indentation for the other statements.</li>
</ul>
<p><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">readNum = do<br>    x &lt;- getLine<br></font></pre></blockquote>
<p>]&gt;<br><br>:l Me.hs<br>=ERROR "Me.hs":9 - Last generator in do {...} must be an expression<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">readNum = do<br>    x &lt;- getLine<br>    return (x)</font></pre></blockquote>
<p>]&gt;<br></p>
<p>notes:<br></p>
<p>
</p>
<ul>
<li>Common error: [ERROR "Me.hs":9 - Last generator in do {...} must be an expression solution: add a return () at the end.]</li>
<li>The error is because we need to return the type of IO rather than x. (more detailed explanation below.)<br>
</li>
<li>The do notation with the funny &lt;- that looks like assignment
is actually just syntax sugar for a higher operation called bind. I
will not be treating that part here.</li>
<li>If you have nothing to return just a return () will do.<br>
</li>
</ul>
<p>The function readNum that you have just defined can not be used like <br>a function that 'returns' a number<br><br>ie:<br><br>|:t readNum<br>=readNum :: IO [Char]<br><br>The type of function is still IO [Char]<br>to convert it to an integer, we need to tell hugs its signature.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">readNum :: IO Integer<br>readNum = do<br>    x &lt;- getLine<br>    return (read x)<br></font></pre></blockquote>
<p>]&gt;<br>|:t readNum<br>=readNum :: IO Integer<br></p>
<p>trying to use it as a function that 'returns' a number fails because the function is no longer pure.<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">mySqr = readNum \* 2<br><br>readNum :: IO Integer<br>readNum = do<br>    x &lt;- getLine<br>    return (read x)</font></pre></blockquote>
<p>]&gt;<br><br>:l My.hs<br>=ERROR "Me.hs":1 - Unresolved top-level overloading<br>\*\*\* Binding             : mySqr<br>\*\*\* Outstanding context : Num (IO Integer)<br><br>For us to make use of an impure function we have to go back to using a monad where ever we need to the result of this function.<br><br>ie:<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">mySqr = do<br>    x &lt;- readNum<br>    print (x \* 2)<br><br>readNum :: IO Integer<br>readNum = do<br>    putStr "Num? "<br>    x &lt;- getLine<br>    return (read x)<br></font></pre></blockquote>
<p>]&gt;<br><br>|mySqr<br>&gt;Num? 12<br>=24<br><br>Let us check the type of the function.<br>:t mySqr<br>=mySqr :: IO ()<br><br></p>
<h4>Explaining return.<br>
</h4>
<p>When using monads, the last line should have the same type as the function itself. The return is a statement that is guaranteed to have the same type.<br><br>that is, from a 'c' approach, the below<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">getName :: IO String<br>getName = do<br>    name &lt;- getLine<br>    return name<br></font></pre></blockquote>
<p>]&gt;<br>should be read as<br><br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">#define Return(x) return to_IO_String(x)<br><br>(IO_String) getName() {<br>    name = getLine()<br>    Return name<br>}</font></pre></blockquote>
<p><br>ie, what is returned is not 'String' but 'IO String'. This is the reason why we are not able to directly use the output of this function in another function that expects a string, but rather use &lt;- to extract the value out of this.</p>
<h4>Trouble shooting</h4>
<p><br>When in doubt, insert braces and ';' to be sure that your indentation is correct.<br>braces can be used after the keywords 'where, let, do, of'<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">len l = case l of {<br>    [] -&gt; 0;<br>    (x:xs) -&gt; 1 + (len xs);</font><br><font face="tahoma,arial,helvetica,sans-serif"></font>}<br></pre></blockquote>
<p>]&gt;<br><br>and be sure to delete them after your scope is clear to you.<br><br>The return does not work as in the other languages either. The only place that a return should be used is as the last statement of a sequence of do actions. <br><br>ie:<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">checkRet = do <br>            putStr "Checking return"<br>            return ()<br>            putStr " here.."<br></font></pre></blockquote>
<p>]&gt;<br><br>|checkRet<br>=Checking return here..<br><br>As you can see, return() does not return from the action being executed by do. It is just a short cut to provide a value of the correct return type for a do.<br><br></p>
<h4>Updatable variables (well not actually)<br>
</h4>
<p>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">import Data.IORef<br><br>myRef = do varA &lt;- newIORef 0<br>           a0 &lt;- readIORef varA<br>           writeIORef varA 1<br>           a1 &lt;- readIORef varA<br>           print (a0, a1)</font><br></pre></blockquote>
<p>]&gt;<br>|myRef<br>=(0,1)<br><br>the newIORef creates and initializes the variable (reference). readIORef  fetches the value, and writeIORef updates it.<br><br></p>
<h4>DataTypes<br>
</h4>
<p>Haskell is strongly typed and has static type system. Generally Haskell infers the type of your expressions (There will be exactly one type for any given expression.). If that fails (like in some of the examples above) You may have to provide explicit type information.<br><br>Haskell provides Integer, Int, Float, Double, Bool, and Char as the most basic building blocks. We can create more complex datatypes on the fly using tuples.<br><br>tuples can be named using the 'type' syntax.<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">type Vert = (Float, Float)<br>type Line = [Vert]<br><br>dist :: Line -&gt; Float<br>dist [(x1,y1), (x2,y2)] = sqrt ((xd \* xd) + (yd \* yd))<br>    where<br>        xd = x2-x1<br>        yd = y2-y1<br></font></pre></blockquote>
<p>]&gt;<br><br><br>You can also build custom datatypes using the 'data' syntax.<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">data Rainbow = Violet | Indigo | Blue | Gree | Yellow | Orange | Red<br>-- define our show function too.<br>instance Show Rainbow where<br>    show Red = ':red'<br>    show Blue = ':blue'</font></pre></blockquote>
<p>]&gt;<br>|Red<br>=:red<br><br>The show function allows you to define the string representation of any custom datatype that you use. I will explain the 'instance' syntax later. but this is how you can define the show function.<br><br></p>
<h4>Using Fields in data<br>
</h4>
<p>when using the field name syntax, the selector functions are already defined.<br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">data Point = Pt {pointx :: Float, pointy :: Float}<br>-- it helps to define a show always.<br>instance Show Point where<br>     show p = show [(pointx p), (pointy p)]<br><br>absPoint                :: Point -&gt; Float<br>absPoint p              =  sqrt (pointx p \* pointx p + <br>                                 pointy p \* pointy p)<br><br>--using pattern matching with field names.<br>absPoint1 (Pt {pointx = x, pointy = y}) = sqrt (x\*x + y\*y) <br><br>-- updating a value using field names.<br>updatePt p = p {pointx=3}<br></font></pre></blockquote>
<p>]&gt;<br><br>|absPoint (Pt {pointx=1, pointy=2})<br>=2.236068<br>|absPoint (Pt 1 2)<br>=2.236068<br>:t pointx<br>=pointx :: Point -&gt; Float<br>|updatePt (Pt 1 2)<br>=[3.0,2.0]<br><br>beware that the field names have the same scope as that of the type, so the same field name can not be used in another type in the same scope.<br>ie the following produces an error.<br><br>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">data Point3 = Pt3 {pointx :: Float, pointy :: Float, pointz :: Float}</font></pre></blockquote>
<p>]&gt;<br>:l <br>=Error - Multiple declarations for selector "pointx"<br><br></p>
<h4>polymorphic data<br>
</h4>
<p>&lt;[<br></p>
<blockquote><pre><font face="tahoma,arial,helvetica,sans-serif">data MyPoint p = Mpt p p<br><br>xmpt :: MyPoint a -&gt; a<br>xmpt (Mpt x y) = x<br>ympt :: MyPoint a -&gt; a<br>ympt (Mpt x y) = x<br><br>-- we get an error 'Can not justify constraints' if we avoid ' =&gt; Show '<br>instance Show a =&gt; Show (MyPoint a) where<br>    show (Mpt a b) = show [a, b]<br></font></pre></blockquote>
<p>]&gt;<br>|Mpt 1 2<br>=[1,2]<br>:t Mpt 1 2<br>=Mpt 1 1 :: Num a =&gt; MyPoint a<br>|Mpt "a" "b"<br>=["a","b"]<br>|:t Mpt "a" "b"<br>Mpt "a" "b" :: MyPoint [Char]<br><br><br></p>
<h4>Using typeclasses (where the Show came from.)<br>
</h4>
<p>&lt;[<br></p>
<blockquote><pre><font><font face="tahoma,arial,helvetica,sans-serif"><br>class Myc a where<br>    (-+-) :: a -&gt; a -&gt; a<br>    (+-+) :: a -&gt; a -&gt; a<br>    (\*\*\*) :: a -&gt; a -&gt; a<br>    x \*\*\* y = x<br><br>instance Myc (String,String) where<br>    x -+- y = y<br>    x +-+ y = x<br><br>instance Myc (Char,Char) where<br>    x -+- y = x<br>    x +-+ y = y<br><br>instance Myc Int where<br>    x -+- y = x<br>    x +-+ y = y</font></font><br><font><font face="tahoma,arial,helvetica,sans-serif"><br>-- using a function that uses Myc<br>myfunc :: (Myc a) =&gt; a -&gt; a<br>myfunc a = a +-+ a<br><br>myf :: (Myc a) =&gt; a -&gt; a<br>myf a = a \*\*\* a<br><br></font></font></pre></blockquote>
<p>]&gt;<br>|:t myfunc<br>=myfunc :: Myc a =&gt; a -&gt; a<br>|myfunc ("a","aa")<br>=("a","aa")<br>|myfunc (1,1)<br>    ERROR - Unresolved overloading<br>    \*\*\* Type       : (Num a, Num b, Myc (b,a)) =&gt; (b,a)<br>    \*\*\* Expression : myfunc (1,1)<br>|myf ('1','2')<br>=('1','2')<br><br></p>
<p> </p>
<p>As you can see, the operator \*\*\* is defined for all types that are instances of class Myc. for the other functions, they have to be implemented by the individual type to be considered an instance of class Myc.</p>
<p>A common error is  </p>
<p> </p>
<pre>|myfunc 1<br>ERROR - Unresolved overloading<br>\*\*\* Type       : (Num a, Myc a) =&gt; a<br>\*\*\* Expression : myfunc 1<br><br></pre>
<p>This happens because there are multiple types that are applicable here. This can be resolved by specifying the type of input explicitly.</p>
<pre>|myfunc (1::Int)<br>=1<br><br></pre>
        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: Technical</p>
        <p class="entry-tags">Tags:    
    	    <a href="https://blogs.oracle.com/blue/tags/language" rel="tag">language</a> 
  	    <a href="https://blogs.oracle.com/blue/tags/programming" rel="tag">programming</a> 
    
 </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/a_thin_slice_of_haskell">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
