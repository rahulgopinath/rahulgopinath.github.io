---
layout: post
category : blog
tagline: "."
tags : [sunmicrosystems blog sun]
---
{% raw %}
<div class="entry" id="dancing_with_xslt_wadm_scripting">

	<h3 class="entry-title">
			Dancing with xslt: wadm scripting for Sun Java System Web Server 7.0 (part IX)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 27, 2006</a>
</h4>

    <div class="entry-body">
                                        	
Though generally wadm returns data as a tcl list that can be directly used, there are<br>multiple instances where more interesting data are made available as Xml. <br><br>Eg:<br><br><span style="color: rgb(51, 51, 255);">|get-stats-xml --config=test --node=agneyam</span><br><font size="2"><span style="font-style: italic;">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">&lt;!DOCTYPE stats SYSTEM "sun-web-server-stats_7_0_0.dtd"&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">&lt;stats versionMajor="1" versionMinor="2" enabled="1"&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">    &lt;server id="https-test" versionServer="Sun Java System Web Server 7.0-Technology"  .... &gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;connection-queue id="cq1"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;thread-pool id="thread-pool-0" name="NativePool"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;thread-pool id="thread-pool-1" name="TestPool"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;profile id="profile-0" name="all-requests" description="All requests"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;profile id="profile-1" name="default-bucket" description="Default bucket"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">        &lt;profile id="profile-2" name="cache-bucket" description="Cached responses"/&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">......</span><br style="font-style: italic;"><span style="font-style: italic;">&lt;/stats&gt;</span><br style="font-style: italic;"><br><br><font size="3">More over the main configuraion file is also in xml.</font><br><font style="color: rgb(51, 51, 255);" size="3">|get-config-file --config=test server.xml</font><br><span style="font-style: italic;">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">&lt;server&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">...</span><br style="font-style: italic;"><span style="font-style: italic;">&lt;/server&gt;</span><br><br><font size="3">There may be times when the normal manipulation of configuration using wadm just dont<br>cut it and you may wish to manipulate the server.xml directly.<br><br></font></font><h4><font size="2"><font size="3">Asking TCL to help</font></font></h4>
<font size="2"><font size="3">Looking at the tcl syntax and the xml syntax again, we see that the xml looks pretty similar<br>infact An xml is nothing but a hierarchy of lists. (This is nothing new, and has been beaten to<br>death by the lisp folks -- the other language that uses lists as the mainstay.)<br><br>We can represent an xml like this<br><font style="color: rgb(0, 153, 0);" size="2">            &lt;thread mode="idle" timeStarted="1161917015" connection-queue="cq1"&gt;<br>                &lt;request-bucket countRequests="0" countBytesReceived="0" countBytesTransmitted="0"/&gt;<br>                &lt;profile-bucket profile="profile-0" countCalls="0" /&gt;<br>                &lt;profile-bucket profile="profile-1" countCalls="0" /&gt;<br>                ABCD<br>            &lt;/thread&gt;<br></font>in tcl syntax as a list as below<br><font size="2"><span style="color: rgb(0, 153, 0);">         thread { </span><span style="color: rgb(0, 153, 0);">:mode "idle" :timestarted "</span></font></font></font><font style="color: rgb(0, 153, 0);" size="2"><font size="3"><font style="color: rgb(0, 153, 0);" size="2">1161917015</font></font></font><font style="color: rgb(0, 153, 0);" size="2"><font size="3">" :connection-queue "cq1"<br>                  request-bucket { :countRequests "0" :countBytesReceived "0" :countBytesTransmitted "0"<br>                                           profile-bucket { :profile "profile-0" :countCalls "0"<br>                                          }<br></font></font><font style="color: rgb(0, 153, 0);" size="2"><font size="3">                                           profile-bucket {:profile "profile-1" :countCalls "0"<br>
                                          }<br>
</font></font><font size="2"><font size="3"><font size="2"><span style="color: rgb(0, 153, 0);">                  }<br>                  % {ABCD}<br style="color: rgb(0, 153, 0);"></span><span style="color: rgb(0, 153, 0);">         }</span><br style="color: rgb(0, 153, 0);"></font><br><br></font></font><font size="2"><font size="3">There are multiple packages available in tcl that can parse the xml (</font></font><a href="http://wiki.tcl.tk/11020" target="_self">this</a> being one of <br>
them<font size="2"><font size="3">), but it is not necessary for us to take that approach. When the language is xml,<br>it is needlessly complicated to parse the xml on our own, instead, It would be nice<br>if there is some tool that would allow us to just specify what we want and where, <br>and convert the xml to that format. In short a macro expander.<br><br></font></font><font size="2"><font size="3">There is a language that fits the bill. </font></font><a href="www.w3.org/TR/xslt" target="_self">XSLT</a><br><h4><font size="2"><font size="3">XSLT</font></font></h4>
<font size="2"><font size="3">Usint XSLT we can transform the xml into tcl source. It allows all the necessary primitives<br>    1) fetch the values of elements and attributes<br>    2) recursively iterate over xml</font></font><br>    3) Compute results and process conditionaly when necessary.<br><br><h4>First try.</h4>Let us try and match all the elements.<br><font style="color: rgb(0, 153, 0);" size="2">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;<br>&lt;xsl:output method="text" encoding="UTF-8"/&gt;<br><br>    &lt;xsl:template match="\*"&gt;<br>        &lt;xsl:value-of select="name()"/&gt;<br>        {<br>        &lt;xsl:apply-templates select="\*"/&gt;<br>        }<br>    &lt;/xsl:template&gt;<br>&lt;/xsl:stylesheet&gt;</font><br><br>
<h4>The infrastructure.</h4>
<font style="color: rgb(204, 0, 0);" size="2">======================transform.tcl=====================<br>namespace eval Transform {<br>    java::import javax.xml.parsers.SAXParserFactory<br>    java::import javax.xml.transform.Source<br>    java::import javax.xml.transform.TransformerFactory<br>    java::import javax.xml.transform.Transformer<br>    java::import javax.xml.transform.stream.StreamSource<br>    java::import javax.xml.transform.stream.StreamResult<br>    java::import javax.xml.transform.sax.SAXSource<br>    java::import org.xml.sax.XMLReader<br>    java::import java.io.File<br>    java::import java.io.ByteArrayOutputStream<br>    java::import java.io.ByteArrayInputStream<br><br>    set xsl {&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;<br>    &lt;xsl:output method="text" encoding="UTF-8"/&gt;<br>    &lt;xsl:template match="\*"&gt;<br>        &lt;xsl:value-of select="name()"/&gt;<br>        {<br>        &lt;xsl:apply-templates select="\*"/&gt;<br>        }<br>    &lt;/xsl:template&gt;<br>&lt;/xsl:stylesheet&gt;<br>}<br><br>    proc get_source {reader arg} {<br>        set stream [java::new ByteArrayInputStream [[java::new String $arg] getBytes]]<br>        set source [java::new StreamSource $stream]<br>        return [java::new SAXSource $reader [java::call SAXSource sourceToInputSource $source]]<br>    }<br><br>    proc xslt {xml} {<br>        set  pfactory [java::call SAXParserFactory newInstance]<br>        $pfactory setValidating 0<br>        set reader [[$pfactory newSAXParser] getXMLReader]<br>        set trans [java::call TransformerFactory newInstance]<br>        set xsl_trans [$trans newTransformer [get_source $reader $Transform::xsl]]<br>        set bo [java::new ByteArrayOutputStream]<br>        $xsl_trans transform [get_source $reader $xml] [java::new StreamResult $bo]<br>        return [$bo toString]<br>    }<br>}<br>===================================================================<br><font size="3"><span style="color: rgb(51, 51, 255);">|source xslt.tcl                                              </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Transform::xslt [get-stats-xml --config test --node agneyam]</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="color: rgb(0, 0, 0); font-style: italic;">ERROR:  'Content is not allowed in prolog.'</span><br style="color: rgb(0, 0, 0); font-style: italic;"><span style="color: rgb(0, 0, 0); font-style: italic;">ERROR:  'com.sun.org.apache.xml.internal.utils.WrappedRuntimeException: Content is not allowed in prolog.'</span><br style="color: rgb(0, 0, 0); font-style: italic;"><span style="color: rgb(0, 0, 0); font-style: italic;">javax.xml.transform.TransformerException: javax.xml.transform.TransformerException: com.sun.org.apache.xml.internal.utils.WrappedRuntimeException: Content is not allowed in prolog.</span></font><br style="color: rgb(0, 0, 0);"></font><br></font>Now, this means that we wont be able to use the xml directly, We need to strip out the starting and<br>ending blank lines, the DocType tag (to avoid validation) etc.<br>Cleaning up the xml file,<br><font style="color: rgb(204, 0, 0);" size="2">===================================================================</font><font style="color: rgb(204, 0, 0);" size="2"><br>    proc clean_xml in {<br>        set out {}<br>        regsub {&lt;!DOCTYPE [\^&gt;]+&gt;} $in {} _out<br>        foreach {line} [split $_out "\\n"] {<br>            switch -regexp -- $line {<br>                {\^$} {} ;#strip blanks.<br>                default { append out $line "\\n" }<br>            }<br>        }<br>        #some command return xml with in a list <br>        #ugly but we dont have an option.<br>        if {[llength $out] == 1} {<br>            set out [lindex $out 0]<br>        }<br>        return $out<br>    }</font><br><font style="color: rgb(204, 0, 0);" size="2">===================================================================</font><br><span style="color: rgb(51, 51, 255);">|source xslt.tcl                                             </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Transform::xslt [get-stats-xml --config test --node agneyam]</span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">....<br>    cpu-info<br>        {<br>        }<br>    cpu-info<br>        {<br>        }<br>        }<br>        }<br></font>Seems to be working..<br>Checking if it is the syntax we are interested in,<br><span style="color: rgb(51, 51, 255);">|array set stats_root [Transform::xslt [get-stats-xml --config test --node agneyam]]<br>|array names stats_root                                                             <br><font size="2"><span style="color: rgb(0, 0, 0); font-style: italic;">stats</span></font><br>|array set stats $stats_root(stats)<br>|array names stats<br><font size="2"><span style="color: rgb(0, 0, 0); font-style: italic;">server</span></font><br>|array set server $stats(server)<br>|array names server<br><font style="color: rgb(0, 0, 0); font-style: italic;" size="2">auth-db audit-accesses connection-queue profile cpu-info http-listener access-log temp-path thread-pool log acl-file jvm default-auth-db-name process http cluster virtual-server mime-file user</font><br></span><br>The tcl list still needs more things to make it completely representative of the xml it parsed.<br>adding those to the xsl,<br><br><font size="2"><span style="color: rgb(0, 153, 0);">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">    &lt;xsl:output method="text" encoding="UTF-8"/&gt;</span><br style="color: rgb(0, 153, 0);"><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">    &lt;xsl:template match="@\*"&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        :&lt;xsl:value-of select="name()"/&gt; "&lt;xsl:value-of select="."/&gt;"</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">    &lt;/xsl:template&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">    &lt;xsl:template match="\*"&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        &lt;xsl:value-of select="name()"/&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        {</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        &lt;xsl:apply-templates select="@\*"/&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        &lt;xsl:apply-templates select="\*"/&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        &lt;xsl:choose&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">            &lt;xsl:when test='string-length(translate(translate(text(),"&amp;#10;","")," ","")) &amp;gt; 1'&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">            % {&lt;xsl:value-of select="translate(text(),'&amp;#10;','')"/&gt;}</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">            &lt;/xsl:when&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        &lt;/xsl:choose&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">        }</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">    &lt;/xsl:template&gt;</span><br style="color: rgb(0, 153, 0);"><span style="color: rgb(0, 153, 0);">&lt;/xsl:stylesheet&gt;</span><br style="color: rgb(0, 153, 0);"></font><br><span style="color: rgb(51, 51, 255);">|array set stats_root [Transform::xslt [get-stats-xml --config test --node agneyam]]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|array names stats_root                                                             </span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">stats</span></font><br><span style="color: rgb(51, 51, 255);">|array set stats $stats_root(stats)                                                 </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|array names stats </span>                                                                 <br><font style="font-style: italic;" size="2">:enabled :versionMajor server :versionMinor</font><br><span style="color: rgb(51, 51, 255);">|puts $stats(:enabled)</span><br><font size="2"><span style="font-style: italic;">1</span></font><br><span style="color: rgb(51, 51, 255);">|array set names $stats(server)</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|array names names</span><br><font style="font-style: italic;" size="2">:secondsRunning connection-queue :load5MinuteAverage profile cpu-info :maxThreads <br>:maxProcs thread-pool :rateBytesReceived :timeStarted :load15MinuteAverage <br>process :load1MinuteAverage :id :rateBytesTransmitted :versionServer virtual-server <br>:ticksPerSecond :flagProfilingEnabled</font><br><span style="color: rgb(51, 51, 255);">|puts $names(profile)</span><br><font size="2"><span style="font-style: italic;">        :id "profile-2"</span><br style="font-style: italic;"><span style="font-style: italic;">        :name "cache-bucket"</span><br style="font-style: italic;"><span style="font-style: italic;">        :description "Cached responses"</span><br style="font-style: italic;"><br style="font-style: italic;"></font>While this seems to be fine, Accessing it through setting and accesssing arrays <br>does not seem to be the friendliest or the most powerful approach,we should <br>provide an API to access the values.<br><br><h4>Creating an API.</h4>What we need is an xpath like expression that allow arbitrary tcl statements to<br>be used for filtering. It should be some thing like below,<br>-- {stats server {profile {~ \*1\* $id} }}<br>where stats/server/profile is the node of the xml we are looking for, and <br>~ \*1\* $id is the filter which will do a pattern match on the value of attribute <br>with name id and return only those nodes that match what we provide.<br><br><font style="color: rgb(204, 0, 0);" size="2">===================================================================<br><span style="color: rgb(204, 0, 0);">     #Filter returns true if either of following is satisfied.</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    #1) the length of filter list is 0 (no filter)</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    #the filter evaluates to true after setting the attributes</span><br style="color: rgb(204, 0, 0);"><span style="color: rgb(204, 0, 0);">    #as variables</span><br style="color: rgb(204, 0, 0);"></font><font style="color: rgb(204, 0, 0);" size="2">    proc filter {filter val} {<br>        if {![string length $filter]} {<br>            return 1<br>        } else {<br>            #transform -&gt;:id "mexico"&lt;- into -&gt;set id "mexico"&lt;-<br>            regsub -all {:([a-zA-Z0-9_-]+) } $val {set \\1 } val<br>            foreach {v} [split $val "\\n"] {<br>                eval $v<br>            }<br>            return [eval $filter]<br>        }<br>    }<br><br>    #collect all elements of name where filter evaluates to true<br>    proc fetch_alist {xml name {filter {}}} {<br>        set res {}<br>        foreach {n v} $xml {<br>            if [string match $n $name] {<br>                if [filter $filter $v] { lappend res $v }<br>            }<br>        }<br>        return $res<br>    }<br><br>    proc helper {lst res} {<br>        set rest [lrange $lst 1 end]<br>        if {![llength $rest]} {<br>            return $res<br>        } else {<br>            set out {}<br>            foreach {r} $res {<br>                set out [concat $out [get $r $rest]]<br>            }<br>            return $out<br>        }<br>    }<br><br>    proc get {xml lst} {<br>        set res $xml<br>        set element [lindex $lst 0]<br>        switch -exact -- [llength $element] {<br>            1 {<br>                #name alone. no filter<br>                #collect the corresponding lists from $xml<br>                set res [fetch_alist $res $element]<br>                return [helper $lst $res]<br>            }<br>            default {<br>                #use filter too.<br>                set res [fetch_alist $res [lindex $element 0] [lindex $element 1]]<br>                return [helper $lst $res]<br>            }<br>        }<br>    }<br></font><font style="color: rgb(204, 0, 0);" size="2">===================================================================</font><br><br><h4>Using It,</h4>(The regexp command is aliased to ~ and string match is aliased to ? -- see full implementation.)<br><span style="color: rgb(51, 51, 255);">|set xml [Transform::xslt [get-stats-xml --config test --node agneyam]]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Transform::get $xml {stats server {profile {~ 1 $id} }}</span><br><font style="font-style: italic;" size="2">{<br>        :id "profile-1"<br>        :name "default-bucket"<br>        :description "Default bucket"<br>        }<br></font><span style="color: rgb(51, 51, 255);"></span><span style="color: rgb(51, 51, 255);">|Transform::get $xml {stats server {profile {? \*1\* $id} }}</span><br><font style="font-style: italic;" size="2">{<br>        :id "profile-1"<br>        :name "default-bucket"<br>        :description "Default bucket"<br>        }</font><br><span style="color: rgb(51, 51, 255);">|Transform::get $xml {stats server {profile {? \* $id} }}  </span><br><font style="font-style: italic;" size="2">{<br>        :id "profile-0"<br>        :name "all-requests"<br>        :description "All requests"<br>        } {<br>        :id "profile-1"<br>        :name "default-bucket"<br>        :description "Default bucket"<br>        } {<br>        :id "profile-2"<br>        :name "cache-bucket"<br>        :description "Cached responses"<br>        }<br></font><br>
The finished transform.tcl is available <a href="../../blue/resource/transform.tcl" target="_self">here</a><br>I will cover using Xpath to access the same data in a later post.<br><br>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/dancing_with_xslt_wadm_scripting">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
