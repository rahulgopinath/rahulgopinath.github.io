---
layout: post
categories : sunblog
tagline: "."
tags : [sunmicrosystems blog sun]
e: Halloween - dressing up as a filesystem wadm scripting (part VII)
---
{% raw %}
<div class="entry" id="halloween_dressing_up_as_a">

	<h3 class="entry-title">
			Halloween :dressing up as a filesystem wadm scripting (part VII)
	    </h3>

    <h4 class="entry-meta">By blue on <a href="#">Oct 23, 2006</a>
</h4>

    <div class="entry-body">
                                        	
In the previous installments, We have been implementing languages over wadm. this time<br>let us turn our attention to something different.<br><br>The Sun Java System Web Server 7.0 provides multiple commands that help us manipulate<br>the configuration. Though they are provided in a flat namespace, the parameters taken by <br>each of the commands suggests that it is actualy a squashed up hierarchy.<br><br>let me illustrate what I mean.<br><br><span style="color: rgb(204, 0, 0); font-weight: bold;">Assume the wadm prompt is "|" so that </span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">|puts new</span><br style="color: rgb(204, 0, 0); font-weight: bold;"><span style="color: rgb(204, 0, 0); font-weight: bold;">is the wadm command "puts new"</span><br><br>type the below commands and tab once.<br><br><span style="color: rgb(51, 51, 255);">|list-config --</span><br>...nothing<br><br><span style="color: rgb(51, 51, 255);">|list-virtual-servers --</span><br><span style="color: rgb(102, 0, 204);">--config\*</span><br><br><span style="color: rgb(51, 51, 255);">|list-http-listeners --</span><br><span style="color: rgb(102, 0, 204);">--config\*</span><br><br><span style="color: rgb(51, 51, 255);">|list-webapps --</span><br><span style="color: rgb(102, 0, 204);">--config\*     --vs\*</span><br><br><span style="color: rgb(51, 51, 255);">|list-dav-collections --</span><br><span style="color: rgb(102, 0, 204);">--config\*     --vs\*</span><br><br><span style="color: rgb(51, 51, 255);">|list-ciphers --</span><br><span style="color: rgb(102, 0, 204);">--config\*          --http-listener\*</span><br><br>What we see above means that even though we see all the commands as a flat namespace<br>they are in reality members of a hierarchy as below. <br><br><table style="width: 453px; height: 116px; text-align: left; margin-left: auto; margin-right: auto;" border="0" cellpadding="4" cellspacing="0">
<tbody>
<tr>
<td style="color: rgb(0, 0, 153);"><br></td>
<td style="color: rgb(0, 0, 153);">config<br>   ||<br>
</td>
<td style="color: rgb(0, 0, 153);"><br></td>
</tr>
<tr>
<td style="color: rgb(0, 0, 153);"> http-listeners<br>         ||<br>
</td>
<td style="color: rgb(0, 0, 153);"></td>
<td style="color: rgb(0, 0, 153);">          virtual-servers <br>           ||                   ||<br>
</td>
</tr>
<tr>
<td style="color: rgb(0, 0, 153);">     ciphers</td>
<td style="color: rgb(0, 0, 153);"><br></td>
<td style="color: rgb(0, 0, 153);">dav-collections     webapps<br>
</td>
</tr>
</tbody>
</table>
<br>and so forth<br>

<br>A filesystem is one of the better ways to represent hierarchical data. More so because users are <br>familiar with filesystems.  To provide an fs view of our commands and data, this is what we will do.<br><br>1) Simplest case: We are at the root of hierarchy<br>      ls :           Show all the applicable list commands (commands that can be executed straight away with out <br>                     any other required option)<br><br>     cd &lt;dir&gt;:  The dir will be the name of a command.that was listed in the ls. <br>                      Save the dir in an internal variable $pwd.<br><br>2) We are one level up and the pwd now contains the name of a command.<br>      ls :           Show the results of executing that command.<br>      cd &lt;dir&gt;:  The dir will be the name of one of the result elements. that was listed in the ls.<br>                     Save the dir in the $pwd.<br><br>3) We are two levels up and the pwd now contains the name of a command and one element of its result<br>      ls :           Show all the applicable list commands (commands that can be executed straight away with out <br>
                     any other required option other than what is there in $pwd)<br>
<br>
     cd &lt;dir&gt;:  The dir will be the name of a command.that was listed in the ls. <br>
                      Save the dir in an internal variable $pwd.<br><br>
This an be continued for any levels with pwd contains alternate command names and one of its results.<br>eg: {list-configs test list-http-listeners http-listener-1 list-ciphers}<br>
<br><h3>Meta wadm.<br>
</h3>
In order for us to do this, We need some meta information:<br>          The list commands supported<br>           their required options<br>           how the arguments map to the commands <br><br>let us see if we can get wadm to describe itself..<br><br><span style="color: rgb(51, 51, 255);">|info commands list-\*</span><br><span style="font-style: italic;">list-http-listeners list-jvm-profilers list-external-jndi-resources list-mail-resource-userprops ...</span><br><br>now to get them to describe themselves.<br>let us try executing one.<br><br><span style="color: rgb(51, 51, 255);">|list-http-listeners</span><br><span style="font-style: italic;">Usage: list-http-listeners --help|-?</span><br style="font-style: italic;"><span style="font-style: italic;">  or   list-http-listeners [--echo] [--no-prompt] [--verbose] [--all] --config=name</span><br style="font-style: italic;"><span style="font-style: italic;">CLI014 config is a required option.</span><br style="font-style: italic;"><br><span style="color: rgb(51, 51, 255);">|list-jvm-profilers </span><br><span style="font-style: italic;">Usage: list-jvm-profilers --help|-?</span><br style="font-style: italic;"><span style="font-style: italic;">  or   list-jvm-profilers [--echo] [--no-prompt] [--verbose] [--all] --config=name</span><br style="font-style: italic;"><span style="font-style: italic;">CLI014 config is a required option.</span><br style="font-style: italic;"><br><br>This is pretty nice, the commands second line in the tcl error output gives us the information we need.<br>let us try and extract the info.<br><br><span style="color: rgb(51, 51, 255);">|foreach {l} [info commands list-\*] {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      if [catch $l err] {</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">            puts  [lindex [split $err "\\n"] 1]</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">      }</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">}</span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">  or   list-http-listeners [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-jvm-profilers [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-external-jndi-resources [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-mail-resource-userprops [--echo] [--no-prompt] [--verbose] --config=name --jndi-name=name<br>  or   list-cgi-dirs [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-acls [--echo] [--no-prompt] [--verbose] [--all] [--vs=name] --config=name<br>  or   list-cgi-envvars [--echo] [--no-prompt] [--verbose] --config=name<br>  or   list-reverse-proxy-uris [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-url-redirects [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-document-dirs [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-lifecycle-module-userprops [--echo] [--no-prompt] [--verbose] [--verbose] --config=name --module=name<br>  or   list-mime-types [--echo] [--no-prompt] [--verbose] [--all] [--vs=name] [--category=type|enc|lang] --config=name<br>  or   list-certs [--echo] [--no-prompt] [--verbose] [--all] [--token=name] [--cert-type=(server | ca; default is 'server')] --config=name<br>  or   list-ciphers [--echo] [--no-prompt] [--verbose] [--cipher-type=ssl2/ssl3tls]  --config=name --http-listener=name<br>  or   list-error-pages [--echo] [--no-prompt] [--verbose] [--all] [--uri-pattern=pattern] --config=name --vs=name<br>  or   list-webapps [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-locks [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name --collection-uri=uri<br>  or   list-jdbc-resource-userprops [--echo] [--no-prompt] [--verbose] [--property-type=type]  --config=name --jndi-name=resourcename<br>  or   list-virtual-servers [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-mail-resources [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-soap-auth-provider-userprops [--echo] [--no-prompt] [--verbose] --config=name --provider=name<br>  or   list-external-jndi-resource-userprops [--echo] [--no-prompt] [--verbose] --config=name --jndi-name=resourcename<br>  or   list-tokens [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-jdbc-resources [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-users [--echo] [--no-prompt] [--verbose] [--all] ( [--uid=wildcardstr] | [--first-name=wildcardstr] | [--last-name=wildcardstr] | [--email=wildcardstr] ) [--vs=name] --config=name --authdb=name<br>  or   list-crls [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-org-units [--echo] [--no-prompt] [--verbose] [--all] [--vs=name] --config=name --authdb=name<br>  or   list-authdb-userprops [--echo] [--no-prompt] [--verbose] [--vs=name]  --config=name --authdb=name<br>  or   list-custom-resources [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-config-files [--echo] [--no-prompt] [--verbose] --config=name<br>  or   list-dav-collections [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-groups [--echo] [--no-prompt] [--verbose] [--all] [--name=filter] [--vs=name] --config=name --authdb=name<br>  or   list-group-members [--echo] [--no-prompt] [--verbose] [--all] [--org-unit=orgunit] [--vs=name] --config=name --authdb=name --group=group-id<br>  or   list-instances [--echo] [--no-prompt] [--verbose] [--all] (--config=name | --node=name)<br>  or   list-events [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-reverse-proxy-headers [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=vs-name --uri-prefix=uri<br>  or   list-authdbs [--echo] [--no-prompt] [--verbose] [--all] [--vs=name] --config=name<br>  or   list-lifecycle-modules [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-auth-realms [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-custom-resource-userprops [--echo] [--no-prompt] [--verbose] --config=name --jndi-name=resourcename<br>  or   list-soap-auth-providers [--echo] [--no-prompt] [--verbose] [--all] --config=name<br>  or   list-jvm-options [--echo] [--no-prompt] [--verbose] [--all] [--profiler=profiler-name] [--debug-options] --config=name<br>  or   list-uri-patterns [--echo] [--no-prompt] [--verbose] [--feature=feature] --config=name --vs=name<br>  or   list-search-collections [--echo] [--no-prompt] [--verbose] [--all] --config=name --vs=name<br>  or   list-auth-realm-userprops [--echo] [--no-prompt] [--verbose] --config=name --realm=name<br></font><br>yes it does seem to help. <br>The things in [--xxx] are optional, so let us strip them away, also the starting 'or cmd-name' <br>since we do not really have any need for those.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">=====================fs.tcl===================<br>namespace eval Fs {<br>    variable commands<br>    proc init {} {<br>        array set Fs::commands {}<br>        foreach {cmd} [info commands list-\*] {<br>            catch {$cmd} err<br>            set line [replace [lindex [split $err "\\n"] 1] {{\^ +or +[a-z-]+} {\\[.+\\]} {=[a-z]+} {\^ +}}]<br>            #handle the either or.<br>            regsub -all -- {\\( \*([a-z=-]+) \*\\| \*([a-z=-]+) \*\\)} $line {\\1} line<br>            set Fs::commands($cmd) $line<br>        }<br>        show<br>    }<br><br>    proc replace {var lst} {<br>        foreach l $lst { regsub -all -- $l $var {} var }<br>        return $var<br>    }<br><br>    proc show {} {<br>        foreach {c} [array names Fs::commands] {<br>            puts "$c: $Fs::commands($c)"<br>        }<br>    }<br>}<br></span><span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);"></span><span style="color: rgb(204, 0, 0);">===========================================</span><br style="color: rgb(204, 0, 0);"></font><br><h4>Using it</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl                 </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Fs::init                      </span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">list-jdbc-resource-userprops: --config --jndi-name<br>list-error-pages: --config --vs<br>list-crls: --config<br>list-lifecycle-modules: --config<br>list-locks: --config --vs --collection-uri<br>list-virtual-servers: --config<br>list-cgi-dirs: --config --vs<br>list-authdb-userprops: --config --authdb<br>list-configs: <br>list-jvm-profilers: --config<br>list-ciphers: --config --http-listener<br>list-custom-resources: --config<br>list-external-jndi-resource-userprops: --config --jndi-name<br>list-soap-auth-provider-userprops: --config --provider<br>list-nodes: <br>list-groups: --config --authdb<br>list-document-dirs: --config --vs<br>list-auth-realms: --config<br>list-lifecycle-module-userprops: --config --module<br>list-auth-realm-userprops: --config --realm<br>list-webapps: --config --vs<br>list-mime-types: --config<br>list-uri-patterns: --config --vs<br>list-events: --config<br>list-authdbs: --config<br>list-jvm-options: --config<br>list-http-listeners: --config<br>list-group-members: --config --authdb --group-id<br>list-mail-resource-userprops: --config --jndi-name<br>list-mail-resources: --config<br>list-reverse-proxy-headers: --config --vs-name --uri-prefix<br>list-users: --config --authdb<br>list-search-collections: --config --vs<br>list-certs: --config<br>list-tokens: --config<br>list-soap-auth-providers: --config<br>list-instances: --config<br>list-custom-resource-userprops: --config --jndi-name<br>list-config-files: --config<br>list-cgi-envvars: --config<br>list-reverse-proxy-uris: --config --vs<br>list-url-redirects: --config --vs<br>list-jdbc-resources: --config<br>list-org-units: --config --authdb<br>list-external-jndi-resources: --config<br>list-acls: --config<br>list-dav-collections: --config --vs<br></font><br>Now the next thing that remains is to figure out how we can extract the mandatory options <br>(an oxymoron if there was one.) <br>let us see how much we can do with wadm itself.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>namespace eval Fs {<br>    variable commands<br>    variable options<br>    proc init {} {<br>        array set Fs::commands {}<br>        array set Fs::options {}<br>        foreach {cmd} [info commands list-\*] {<br>            catch {$cmd} err<br>            set line [replace [lindex [split $err "\\n"] 1] {{\^ +or +[a-z-]+} {\\[.+\\]} {=[a-z-]+} {\^ +}}]<br>            regsub -all -- {\\( \*([a-z=-]+) \*\\| \*([a-z=-]+) \*\\)} $line {\\1} line<br>            set Fs::commands($cmd) $line<br>        }<br>        parseopt<br>        show<br>    }<br><br>    proc replace {var lst} {<br>        foreach l $lst { regsub -all -- $l $var {} var }<br>        return $var<br>    }<br><br>    proc default_opts {c} {<br>        #if the next statement does not throw, it is what we are looking for.<br>        set req $Fs::commands(list-[set c]s)<br>        set Fs::options($c) $c<br>    }<br><br>    proc parseopt {} {<br>        array set undefopt {}<br>        foreach {c} [array names Fs::commands] {<br>            set os [replace $Fs::commands($c) {--}]<br>            foreach {o} $os {<br>                set undefopt($o) $c<br>            }<br>        }<br>        foreach {c} [array names undefopt] {<br>            if [catch "default_opts $c" err] {<br>                puts "=&gt; $err"<br>            }<br>        }<br>    }<br><br>    proc show {} {<br>        foreach o [array names Fs::options] {<br>            puts "$o =&gt; $Fs::options($o)"<br>        }<br>    }<br>}<br><br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><font size="2"><span style="color: rgb(204, 0, 0);"></span></font><br><h4>Using It</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl            </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Fs::init                 </span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">=&gt; can't read "Fs::commands(list-modules)": no such element in array<br>=&gt; can't read "Fs::commands(list-collection-uris)": no such element in array<br>=&gt; can't read "Fs::commands(list-uri-prefixs)": no such element in array<br>=&gt; can't read "Fs::commands(list-realms)": no such element in array<br>=&gt; can't read "Fs::commands(list-jndi-names)": no such element in array<br>=&gt; can't read "Fs::commands(list-providers)": no such element in array<br>=&gt; can't read "Fs::commands(list-vss)": no such element in array<br>http-listener =&gt; http-listener<br>module =&gt; lifecycle-module<br>uri =&gt; reverse-proxy-uri<br>config =&gt; config<br>collection =&gt; dav-collection<br>realm =&gt; auth-realm<br>provider =&gt; soap-auth-provider<br>group =&gt; group<br>authdb =&gt; authdb<br><br></font>
Looking at the  things that are not there, there seems to be a pattern,<br>if the option is xxxx, then there seems to be a command list-yyy-xxxxs.<br>that is if option is module, the command is list-lifecycle-modules. So adding <br>that also to our script.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>namespace eval Fs {<br>    variable commands<br>    variable options<br>    proc init {} {<br>        array set Fs::commands {}<br>        array set Fs::options {}<br>        foreach {cmd} [info commands list-\*] {<br>            catch {$cmd} err<br>            set line [replace [lindex [split $err "\\n"] 1] {{\^ +or +[a-z-]+} {\\[.+\\]} {=[a-z-]+} {\^ +}}]<br>            regsub -all -- {\\( \*([a-z=-]+) \*\\| \*([a-z=-]+) \*\\)} $line {\\1} line<br>            set Fs::commands($cmd) $line<br>        }<br>        parseopt<br>        show<br>    }<br><br>    proc replace {var lst} {<br>        foreach l $lst { regsub -all -- $l $var {} var }<br>        return $var<br>    }<br><br>    proc default_opts {c cmd} {<br>        #if the next statement does not throw, it is what we are looking for.<br>        set req $Fs::commands(list-[set c]s)<br>        set Fs::options($c) $c<br>    }<br><br>    proc second_opts {c cmd} {<br>        #check if the following is true<br>        #if option is xxxx then command is list-yyyy-'xxxxs'$<br>        foreach {cmd} [info commands list-\*[set c]s] {<br>            if {![catch {set req $Fs::commands($cmd)} err]} {<br>                set Fs::options($c) [replace $cmd {{list-} {s$}}]<br>                return<br>            }<br>        }<br>        error "$c does not match for $cmd."<br>    }<br><br>    proc final_opts {c cmd} {<br>        puts "$c does not match for $cmd."<br>    }<br><br>    proc parseopt {} {<br>        array set undefopt {}<br>        foreach {c} [array names Fs::commands] {<br>            set os [replace $Fs::commands($c) {--}]<br>            foreach {o} $os {<br>                set undefopt($o) $c<br>            }<br>        }<br>        foreach {c} [array names undefopt] {<br>            foreach {cmd} {default_opts second_opts final_opts} {<br>                if {![catch "$cmd $c $undefopt($c)" err]} {<br>                    break<br>                }<br>            }<br>        }<br>    }<br><br>    proc show {} {<br>        foreach o [array names Fs::options] {<br>            puts "$o =&gt; $Fs::options($o)"<br>        }<br>    }<br>}<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><br><br>Here We are trying to use three methods, default_opts second_ops, final_opts in an attempt<br>to match the options. The default_opts and second_opts tries to find a corresponding list command<br>while final_opts acts as a guard. If it reaches there, then our heuristics did not work. <br><br>The reason for such a scheme is that it makes it easy to add new procedures.<br><h4>Using It</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Fs::init     </span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;"></span><span style="font-style: italic;">collection-uri does not match for list-locks.<br>uri-prefix does not match for list-reverse-proxy-headers.<br>jndi-name does not match for list-custom-resource-userprops.<br>vs does not match for list-dav-collections.<br>http-listener =&gt; http-listener<br>module =&gt; lifecycle-module<br>uri =&gt; reverse-proxy-uri<br>config =&gt; config<br>collection =&gt; dav-collection<br>realm =&gt; auth-realm<br>provider =&gt; soap-auth-provider<br>group =&gt; group<br>authdb =&gt; authdb<br></span><span style="font-style: italic;"></span><br style="font-style: italic;"></font><br>Of the four remaining, we notice more patterns,<br>if an option is of the form --firstword-secondword, then there is a good chance<br>that there is a list command of the form list-xxx-yyy-'firstword's<br>Including this heuristics again in our engine.<br><br>The modification to fs.tcl will be:<br><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>    proc third_opts {c cmd} {<br>        #extract the first word eg: <br>        #--uri-prefix # =&gt; uri and match it with uris$ =: list-reverse-proxy-uris<br>        #--collection-uri =&gt; collection and match with colections$ =: list-dav-collections<br>        second_opts [replace $c {-[a-z]+$}] cmd<br>    }<br>    proc parseopts {} {<br>     .....<br>          foreach {cmd} {default_opts second_opts third_opts final_opts} {<br>     ....<br>     }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><br><br><h4>Using It.</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Fs::init     </span><br><font size="2"><span style="font-style: italic;"></span><span style="font-style: italic;">jndi-name does not match for list-custom-resource-userprops.<br>vs does not match for list-dav-collections.</span><br style="font-style: italic;"><span style="font-style: italic;">http-listener =&gt; http-listener</span><br style="font-style: italic;"><span style="font-style: italic;">module =&gt; lifecycle-module</span><br style="font-style: italic;"><span style="font-style: italic;">uri =&gt; reverse-proxy-uri</span><br style="font-style: italic;"><span style="font-style: italic;">config =&gt; config</span><br style="font-style: italic;"><span style="font-style: italic;">collection =&gt; dav-collection</span><br style="font-style: italic;"><span style="font-style: italic;">realm =&gt; auth-realm</span><br style="font-style: italic;"><span style="font-style: italic;">provider =&gt; soap-auth-provider</span><br style="font-style: italic;"><span style="font-style: italic;">group =&gt; group</span><br style="font-style: italic;"><span style="font-style: italic;">authdb =&gt; authdb</span><br style="font-style: italic;"><br style="font-style: italic;"></font>Of the remaining the jndi-name can be included with one more rule.<br><span style="color: rgb(51, 51, 255);">|info commands list-\*jndi\*</span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">list-external-jndi-resources list-external-jndi-resource-userprops</span></font><br><br>ie, if a command starts with list- and is not the same command that missed it,<br>and contains the first word of option and does not end in userprops, and the remaining<br>is just one then it is a good candidate. Adding this logic results in just one option left out.<br>--vs =&gt; list-virtual-servers<br>since there does not seem to be any connection between the option and the corresponding <br>list, we will simply add an option to override the associated commands when needed, and<br>add this.<br><br><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>namespace eval Fs {<br>    variable commands<br>    variable options<br>    variable default_options<br>    proc init {} {<br>        array set Fs::commands {}<br>        array set Fs::options {}<br>        array set Fs::default_options {vs virtual-server}<br><br>        foreach {cmd} [info commands list-\*] {<br>            catch {$cmd} err<br>            set line [replace [lindex [split $err "\\n"] 1] {{\^ +or +[a-z-]+} {\\[.+\\]} {=[a-z-]+} {\^ +}}]<br>            regsub -all -- {\\( \*([a-z=-]+) \*\\| \*([a-z=-]+) \*\\)} $line {\\1} line<br>            set Fs::commands($cmd) $line<br>        }<br>        parseopt<br>        #overriding the options.<br>        array set Fs::options [array get Fs::default_options]<br>        show<br>    }<br><br>    proc replace {var lst} {<br>        foreach l $lst { regsub -all -- $l $var {} var }<br>        return $var<br>    }<br><br>    proc default_opts {c cmd} {<br>        #if the next statement does not throw, it is what we are looking for.<br>        set req $Fs::commands(list-[set c]s)<br>        set Fs::options($c) $c<br>    }<br><br>    proc second_opts {c cmd} {<br>        #check if the following is true<br>        #if option is xxxx then command is list-yyyy-'xxxxs'$<br>        foreach {cm} [info commands list-\*[set c]s] {<br>            set Fs::options($c) [replace $cm {{list-} {s$}}]<br>            return<br>        }<br>        error "$c does not match for $cmd."<br>    }<br><br>    proc third_opts {c cmd} {<br>        #extract the first word eg: <br>        #--uri-prefix # =&gt; uri and match it with uris$ =: list-reverse-proxy-uris<br>        #--collection-uri =&gt; collection and match with colections$ =: list-dav-collections<br>        second_opts [replace $c {-[a-z]+$}] cmd<br>    }<br><br>    proc fourth_opts {c cmd} {<br>        #extract the first word.<br>        regexp {\^[a-z]+} $c first<br>        #if option is xxxx then command is list-yyyy-'xxxx'-zzzs$<br>        set opt {}<br>        foreach {cm} [info commands list-\*[set first]\*] {<br>            if {![string compare $cmd $cm]} {<br>                #we are the same command.<br>                continue<br>            }<br>            if [regexp {userprops$} $cm] {<br>                #ends with userprops<br>                continue<br>            }<br>            if {[string length $opt]} {<br>                error "$c:$cmd fourth opt bags more than one."<br>            }<br>            set opt [replace $cmd {{list-} {s$}}]<br>        }<br>        if {![string length $opt]} {<br>            error "$c:$cmd not even one option"<br>        }<br>        set Fs::options($c) $opt<br>    }<br><br>    proc final_opts {c cmd} {<br>        if {![info exists Fs::default_options($c)]} {<br>            puts "$c does not match for $cmd."<br>        }<br>    }<br><br><br>    proc parseopt {} {<br>        array set undefopt {}<br>        foreach {c} [array names Fs::commands] {<br>            set os [replace $Fs::commands($c) {--}]<br>            foreach {o} $os {<br>                set undefopt($o) $c<br>            }<br>        }<br>        foreach {c} [array names undefopt] {<br>            foreach {cmd} {default_opts second_opts third_opts fourth_opts final_opts} {<br>                if {![catch "$cmd $c $undefopt($c)" err]} {<br>                    break<br>                }<br>            }<br>        }<br>    }<br><br>    proc show {} {<br>        foreach o [array names Fs::options] {<br>            puts "$o =&gt; $Fs::options($o)"<br>        }<br>    }<br>}<br><br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><br><br><h4>Using it</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|Fs::init     </span><br style="color: rgb(51, 51, 255);"><font size="2"><span style="font-style: italic;">http-listener =&gt; http-listener</span><br style="font-style: italic;"><span style="font-style: italic;">module =&gt; lifecycle-module</span><br style="font-style: italic;"><span style="font-style: italic;">uri =&gt; reverse-proxy-uri</span><br style="font-style: italic;"><span style="font-style: italic;">config =&gt; config</span><br style="font-style: italic;"><span style="font-style: italic;">collection =&gt; dav-collection</span><br style="font-style: italic;"><span style="font-style: italic;">realm =&gt; auth-realm</span><br style="font-style: italic;"><span style="font-style: italic;">jndi-name =&gt; custom-resource-userprop</span><br style="font-style: italic;"><span style="font-style: italic;">provider =&gt; soap-auth-provider</span><br style="font-style: italic;"><span style="font-style: italic;">group =&gt; group</span><br style="font-style: italic;"><span style="font-style: italic;">authdb =&gt; authdb</span><br style="font-style: italic;"><span style="font-style: italic;">vs =&gt; virtual-server</span><br style="font-style: italic;"><br><font size="3"><br>The hard work is mostly over, all we need to do now is to implement the commands<br>ls, pwd, cd<br>for a reasonable approximation of a filesystem.<br><br></font></font><h3><font size="2"><font size="3">The path representation.</font></font></h3>
<font size="2"><font size="3">We will use the following for path.<br>|&lt;option-commandname&gt;:&lt;option-value&gt;|&lt;option-commandname&gt;:option-value| etc....&gt;<br><br>in EBNF, it will be<br></font></font><font size="2"><font size="3">("|" &lt;option-commandname&gt; ":" &lt;option-value&gt; )\* "&gt;"</font></font><br><font size="2"><font size="3"><br></font></font><font size="2"><font size="3">For this, it is easier to just save the path as a list containing &lt;optcmdname&gt;, &lt;value&gt; multiple times<br>and convert to the representation when the need arises.<br><br></font></font><h3><font size="2"><font size="3">The pwd</font></font></h3>
<font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>    proc pwd {} {<br>        set p ""<br>        foreach {c v} $Fs::pwd { set p "$p|$c:$v" }<br>        return $p<br>    }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><br><font size="2"><font size="3"><br></font></font><h3><font size="2"><font size="3">The ls</font></font></h3>
<font size="2"><font size="3">We need to know if we are currently in an option or in a value.<br></font></font><font size="2"><font size="3">option_folder will return true if we are on an option. ie<br>
if pwd =&gt; {config} it will return true, but <br>
pwd =&gt; {config test} will return false<br>The in_current_folder is also important. It checks to see if the command really<br>belongs to this folder (if all the required options are defined, and also that <br>the command really needs all the options defined now. if either of conditions is<br>false then it is not in current folder.)<br></font></font><font size="2"><span style="color: rgb(204, 0, 0);"></span></font><br><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>    proc in_current_folder {c} {<br>       set params $Fs::commands($c)<br>       foreach {opt -} $Fs::pwd {<br>            #=&gt; config: :test vs: :mexico<br>            if {![regsub -all -- "--[get_opt $opt]" $params {} params]} { <br>                #match failed, it is in one of parent/different folders.<br>                return 0<br>            }<br>        }<br>        return [expr [llength $params] == 0]<br>    }<br><br>    proc option_folder {} {<br>        return [expr [llength $Fs::pwd] % 2]<br>    }<br><br>    proc option_folder {} {<br>        return [expr [llength $Fs::pwd] % 2]<br>    }<br><br>    proc cmd_name cmd {<br>        return "list-[set cmd]s"<br>    }<br><br>    proc sane_cmd_name c {<br>        return [replace $c {{\^list-} {s$}}]<br>    }<br><br>    proc get_opt opt {<br>        if [info exist Fs::options($opt)] {<br>            return $Fs::options($opt)<br>        } else {<br>            return $opt<br>        }<br>    }<br><br>    proc options {c} {<br>        set cmd $Fs::commands($c)<br>        foreach {opt val} $Fs::pwd {<br>            regsub -all -- "--[get_opt $opt]" $cmd "--[get_opt $opt]=$val" cmd<br>        }<br>        return $cmd<br>    }<br><br>    proc ls args {<br>        set out {}<br>        if [option_folder] {<br>            #show values for only this command.<br>            set c [cmd_name [lindex $Fs::pwd end]]<br>            set out [concat $out [lsort [eval "$c [options $c]"]]]<br>        } else {<br>            foreach {c} [array names Fs::commands] {<br>                if [in_current_folder $c] {<br>                    lappend out [sane_cmd_name $c]<br>                }<br>            }<br>        }<br><br>        #output.<br>        foreach {l} [lsort $out] { puts $l }<br>    }<br><br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================</span></font><br><font size="2"><span style="color: rgb(204, 0, 0);"></span></font><font size="2"><font size="3"><br>We also need cd to check it out<br><br></font></font><h4><font size="2"><font size="3">The cd</font></font></h4>
<font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br>    proc cd {arg} {<br>        #config:test<br>        #config:mexico<br>        switch -regexp -- $arg {<br>            {\\.\\.} {<br>                pop_pwd<br>                unset_last_wadm_var<br>            }<br>            {\\.} {<br>                puts $Fs::pwd<br>            }<br>            default {<br>                push_pwd $arg<br>                set_wadm_var<br>           }<br>        }<br>        return<br>    }<br></span></font><font size="2"><span style="color: rgb(204, 0, 0);">===========================================<br><br></span></font><font size="2"><span style="color: rgb(204, 0, 0);"></span></font><br>
The complete implementation is available <a href="../../blue/resource/fs.tcl" target="_self">here</a><font size="2"><span style="color: rgb(204, 0, 0);"><br></span></font><h4>Using It</h4>
<span style="color: rgb(51, 51, 255);">|source fs.tcl</span><br><span style="color: rgb(51, 51, 255);">|Fs::init     </span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|interp alias {} cd {} Fs::cd </span><br><font size="2"><span style="font-style: italic;">cd</span></font><br><span style="color: rgb(51, 51, 255);">&gt;interp alias {} ls {} Fs::ls</span><br><font style="font-style: italic;" size="2">ls</font><br><span style="color: rgb(51, 51, 255);">&gt;ls</span><br><font style="font-style: italic;" size="2">config<br>node<br></font><span style="color: rgb(51, 51, 255);">&gt;cd config</span><br><font size="2"><span style="font-style: italic;">&gt;</span></font><br><span style="color: rgb(51, 51, 255);">|config:&gt;ls</span><br><font size="2"><span style="font-style: italic;">apache-temp</span><br style="font-style: italic;"><span style="font-style: italic;">emxico</span><br style="font-style: italic;"><span style="font-style: italic;">security</span><br style="font-style: italic;"><span style="font-style: italic;">test</span><br style="font-style: italic;"></font><span style="color: rgb(51, 51, 255);">|config:&gt;cd test</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|config:&gt;ls</span><br><font style="font-style: italic;" size="2">acl<br>auth-realm<br>authdb<br>cert<br>cgi-envvar<br>config-file<br>crl<br>custom-resource<br>event<br>external-jndi-resource<br>http-listener<br>instance<br>jdbc-resource<br>jvm-option<br>jvm-profiler<br>lifecycle-module<br>mail-resource<br>mime-type<br>soap-auth-provider<br>token<br>virtual-server<br></font><span style="color: rgb(51, 51, 255);">|config:test&gt;cd http-listener</span><br style="color: rgb(51, 51, 255);"><span style="color: rgb(51, 51, 255);">|config:test&gt;ls</span><br><font style="font-style: italic;" size="2">http-listener-1<br>newlist<br></font><span style="color: rgb(51, 51, 255);">|config:test|http-listener:&gt;ls port=\*99</span><br><font style="font-style: italic;" size="2">newlist</font><br><span style="color: rgb(51, 51, 255);">|config:test|http-listener:&gt;info vars wadm_\*</span><br><font size="2"><span style="font-style: italic;">
wadm_histfile wadm_user wadm_config wadm_password wadm_savehist wadm_mode wadm_prompt</span></font><br>
<span style="color: rgb(51, 51, 255);"></span><span style="color: rgb(51, 51, 255);">|config:test|http-listener:&gt;cd ..</span><br style="color: rgb(51, 51, 255);"><font style="font-style: italic;" size="2">|config:test|http-listener:&gt;</font><br><span style="color: rgb(51, 51, 255);">|config:test&gt;cd ..</span><br><font size="2"><span style="font-style: italic;">|config:test&gt;</span><br style="font-style: italic;"><span style="font-style: italic;">|config:&gt;</span><br style="font-style: italic;"><br><br><font size="3">As you can see you can even list by the properties (where get-xxx-prop is available for the option xxx<br>if it is not available you will get an error.)</font><br><font size="3">More over it will also set and unset the corresponding wadm_xxx vars for each directory traversed.</font><br><br>the finished </font><a href="../../blue/resource/fs.tcl" target="_self">fs.tcl</a><br><font size="2"><font size="1"><br></font><br style="font-style: italic;"></font>

        
    </div>

    <div class="entry-footer">
        <p class="entry-category">Category: wadm</p>
        <p class="entry-tags">Tags:  none </p>
        <p class="entry-links">
        <a href="https://blogs.oracle.com/blue/entry/halloween_dressing_up_as_a">Permanent link to this entry</a>
                        </p>
    </div>

	    
	</div>
{% endraw %}
