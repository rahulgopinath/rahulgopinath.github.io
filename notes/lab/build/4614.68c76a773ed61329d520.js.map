{"version":3,"file":"4614.68c76a773ed61329d520.js","mappings":"sSAUO,MAAMA,EAITC,YAAYC,GACRC,KAAKC,SAAW,IAAI,EAAAC,OAAOF,MAC3BA,KAAKG,UAAY,IAAI,EAAAD,OAAOF,MAC5BA,KAAKI,QAAU,KACfJ,KAAKK,WAAa,IAAI,EAAAH,OAAOF,MAC7BA,KAAKM,aAAc,EACnBN,KAAKO,SAAW,EAChBP,KAAKQ,UAAW,EAChBR,KAAKS,oBAAsB,KAC3BT,KAAKU,WAAaX,EAAQY,UAC1BX,KAAKY,YAAcb,EAAQc,WAC3Bb,KAAKc,WAAa,IAAI,EAAAC,UAAUf,KAAKgB,eAAeC,KAAKjB,MAAO,KAKpE,cACI,OAAOA,KAAKC,SAKhB,eACI,OAAOD,KAAKG,UAKhB,gBACI,OAAOH,KAAKK,WAKhB,aACI,OAAOL,KAAKI,QAEhB,WAAWc,GACP,GAAIA,IAAalB,KAAKI,QAClB,OAGJ,EAAAF,OAAA,mBAA0BF,MAC1B,MAAMmB,EAAUnB,KAAKI,QAAUc,EAC3BC,IAEAnB,KAAKC,SAASmB,UAAK,GAGnBpB,KAAKgB,iBACLG,EAAOE,MAAMC,WAAWC,QAAQC,QAAQxB,KAAKyB,UAAWzB,MACxDmB,EAAOE,MAAMK,MAAMH,QAAQC,QAAQxB,KAAKyB,UAAWzB,OAU3D,cACI,OAAOA,KAAKQ,SAEhB,YAAYkB,GACR1B,KAAKQ,SAAWkB,EAQpB,iBACI,OAAO1B,KAAKM,YAKhBqB,UACQ3B,KAAK4B,aAGT5B,KAAKM,aAAc,EACnBN,KAAKG,UAAUiB,UAAK,GACpB,EAAAlB,OAAA,UAAiBF,OAQrBgB,eAAea,GAEX,GAAI7B,KAAKQ,SACL,OAEJ,MAAMW,EAASnB,KAAKmB,OACpB,IAAKA,EACD,OAEJ,MAAMW,EAAOD,GAA0BV,EAAOE,MAAMK,MAAMI,KACpDC,EAAWZ,EAAOa,oBAClBC,EAAS,EAAAC,KAAA,mBAAwBf,EAAOgB,YAAYJ,GAAWD,GAC/DM,EAAS,CAAEC,QAAS,MACpBC,IAAYtC,KAAKO,SAClBP,KAAKU,WACL6B,MAAM,CAAEN,OAAAA,EAAQH,KAAAA,IAChBU,MAAKC,IAEN,IAAKA,GAASzC,KAAK4B,YAAcU,IAAYtC,KAAKO,SAG9C,OAFAP,KAAKS,oBAAsB,UAC3BT,KAAKK,WAAWe,KAAKgB,GAGzB,MAAM,KAAEM,GAASD,EAEjB,GAAIzC,KAAKS,qBACL,EAAAkC,QAAA,UAAkB3C,KAAKS,oBAAqBiC,GAC5C,OAEJ,MAAME,EAAW5C,KAAKY,YAAYiC,kBAAkBH,GACpD,GAAIE,EAAU,CACV,MAAME,EAAS9C,KAAKY,YAAYmC,eAAeH,GACzCvB,EAAQ,IAAI,EAAA2B,UAAU,CAAEN,KAAAA,IACzBI,EAAOG,YAAY5B,GACxBe,EAAOC,QAAUS,EAErB9C,KAAKS,oBAAsBgC,EAAMC,KACjC1C,KAAKK,WAAWe,KAAKgB,MAEpBc,OAAMC,IAEPnD,KAAKS,oBAAsB,KAC3BT,KAAKK,WAAWe,KAAKgB,MAM7BX,YACSzB,KAAKc,WAAWsC,U,qCCpJ7B,MAIMC,EAAgB,uBAQf,MAAMC,UAAuB,EAAAC,MAIhCzD,YAAYC,EAAU,IAClByD,QACAxD,KAAKyD,QAAU,KACfzD,KAAK0D,WAAa3D,EAAQ2D,YAAc,EAAAC,eACxC3D,KAAK4D,OAAS5D,KAAK0D,WAAWG,KAAK,cAC/B9D,EAAQ+D,0BAA0B,EAAAC,OAClC/D,KAAKgE,SAAWjE,EAAQ+D,eAEe,iBAA3B/D,EAAQ+D,eACpB9D,KAAKgE,SAAWV,EAAeW,uBAAuB,MAAMlE,EAAQ+D,sBAGpE9D,KAAKgE,SAAWV,EAAeW,uBAAuB,MAClDjE,KAAK4D,OAAOM,GAAG,6CACf,QAERlE,KAAKmE,SAhCO,gBAiCZnE,KAAKoE,OAAOC,UAAUrE,KAAKgE,UAK/B,CAAC,EAAAM,SAAA,UACG,MAAO,IAAM,EAAAA,SAAA,YAAqBtE,MAKtC,aACI,OAAOA,KAAKyD,QAEhB,WAAWc,GACHvE,KAAKyD,UAAYc,IAIjBvE,KAAKyD,UACLzD,KAAKyD,QAAQe,SAAU,EACvBxE,KAAKyD,QAAQgB,UAAUC,WAAW1E,KAAK2E,kBAAmB3E,MAC1DA,KAAKyD,QAAQmB,SAASF,WAAW1E,KAAK6E,iBAAkB7E,OAGxDuE,GAAUA,EAAO3C,aACjB2C,EAAS,MAGbvE,KAAKyD,QAAUc,EAEXvE,KAAKyD,UACLzD,KAAKyD,QAAQe,SAAU,EACvBxE,KAAKyD,QAAQgB,UAAUjD,QAAQxB,KAAK2E,kBAAmB3E,MACvDA,KAAKyD,QAAQmB,SAASpD,QAAQxB,KAAK6E,iBAAkB7E,QAM7D2B,UACQ3B,KAAK4B,aAGT5B,KAAKuE,OAAS,KACdf,MAAM7B,WAKVgD,kBAAkBG,EAAQC,GACtB,MAAM,QAAE1C,GAAY0C,EAEf1C,GAAWA,IAAYrC,KAAKgE,WAGjChE,KAAKgE,SAASrC,UACd3B,KAAKgE,SAAW3B,EAChBA,EAAQ8B,SAASd,GACjBrD,KAAKoE,OAAOC,UAAUhC,IAK1BwC,iBAAiBC,EAAQC,GACrB/E,KAAKuE,OAAS,KAKlB,8BAA8BS,GAC1B,MAAMlC,EAAS,IAAI,EAAAiB,OAInB,OAHAjB,EAAOmC,KAAKC,UAAYF,EACxBlC,EAAOqB,SAASd,GAChBP,EAAOqB,SAnGe,gCAoGfrB,G,cC9GR,MAAMqC,UAAwB,EAAAC,cAMjCtF,YAAYC,GACRyD,QACAxD,KAAKqF,gBAAkBtF,EAAQuF,eAOnC/C,MAAMgD,GACF,IAAIC,EACJ,MAAMC,EAAiD,QAAvCD,EAAKxF,KAAKqF,gBAAgBK,eAA4B,IAAPF,OAAgB,EAASA,EAAGC,OAC3F,IAAKA,EACD,OAAOE,QAAQC,OAAO,IAAIC,MAAM,wCAEpC,MAAMC,EAAW,CACbC,KAAMR,EAAQzD,KACdkE,WAAYT,EAAQtD,OACpBgE,aAAc,GAElB,OAAOR,EAAOS,eAAeJ,GAAUtD,MAAK2D,IACxC,MAAMC,EAAWD,EAAI9D,QACrB,GAAwB,OAApB+D,EAASC,SAAoBD,EAASE,MACtC,MAAM,IAAIT,MAAM,mDAEpB,MAAO,CAAEnD,KAAM0D,EAAS1D,KAAM6D,SAAUH,EAASG,cC9BtD,MAAMC,EAAa,IAAI,EAAAC,MAAM","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/inspector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/kernelconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../node_modules/@jupyterlab/inspector/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nimport { MimeModel } from '@jupyterlab/rendermime';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * An object that handles code inspection.\n */\nexport class InspectionHandler {\n    /**\n     * Construct a new inspection handler for a widget.\n     */\n    constructor(options) {\n        this._cleared = new Signal(this);\n        this._disposed = new Signal(this);\n        this._editor = null;\n        this._inspected = new Signal(this);\n        this._isDisposed = false;\n        this._pending = 0;\n        this._standby = true;\n        this._lastInspectedReply = null;\n        this._connector = options.connector;\n        this._rendermime = options.rendermime;\n        this._debouncer = new Debouncer(this.onEditorChange.bind(this), 250);\n    }\n    /**\n     * A signal emitted when the inspector should clear all items.\n     */\n    get cleared() {\n        return this._cleared;\n    }\n    /**\n     * A signal emitted when the handler is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * A signal emitted when an inspector value is generated.\n     */\n    get inspected() {\n        return this._inspected;\n    }\n    /**\n     * The editor widget used by the inspection handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        // Remove all of our listeners.\n        Signal.disconnectReceiver(this);\n        const editor = (this._editor = newValue);\n        if (editor) {\n            // Clear the inspector in preparation for a new editor.\n            this._cleared.emit(void 0);\n            // Call onEditorChange to cover the case where the user changes\n            // the active cell\n            this.onEditorChange();\n            editor.model.selections.changed.connect(this._onChange, this);\n            editor.model.value.changed.connect(this._onChange, this);\n        }\n    }\n    /**\n     * Indicates whether the handler makes API inspection requests or stands by.\n     *\n     * #### Notes\n     * The use case for this attribute is to limit the API traffic when no\n     * inspector is visible.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(value) {\n        this._standby = value;\n    }\n    /**\n     * Get whether the inspection handler is disposed.\n     *\n     * #### Notes\n     * This is a read-only property.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n        Signal.clearData(this);\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     *\n     * #### Notes\n     * Update the hints inspector based on a text change.\n     */\n    onEditorChange(customText) {\n        // If the handler is in standby mode, bail.\n        if (this._standby) {\n            return;\n        }\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        const text = customText ? customText : editor.model.value.text;\n        const position = editor.getCursorPosition();\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        const update = { content: null };\n        const pending = ++this._pending;\n        void this._connector\n            .fetch({ offset, text })\n            .then(reply => {\n            // If handler has been disposed or a newer request is pending, bail.\n            if (!reply || this.isDisposed || pending !== this._pending) {\n                this._lastInspectedReply = null;\n                this._inspected.emit(update);\n                return;\n            }\n            const { data } = reply;\n            // Do not update if there would be no change.\n            if (this._lastInspectedReply &&\n                JSONExt.deepEqual(this._lastInspectedReply, data)) {\n                return;\n            }\n            const mimeType = this._rendermime.preferredMimeType(data);\n            if (mimeType) {\n                const widget = this._rendermime.createRenderer(mimeType);\n                const model = new MimeModel({ data });\n                void widget.renderModel(model);\n                update.content = widget;\n            }\n            this._lastInspectedReply = reply.data;\n            this._inspected.emit(update);\n        })\n            .catch(reason => {\n            // Since almost all failures are benign, fail silently.\n            this._lastInspectedReply = null;\n            this._inspected.emit(update);\n        });\n    }\n    /**\n     * Handle changes to the editor state, debouncing.\n     */\n    _onChange() {\n        void this._debouncer.invoke();\n    }\n}\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Printing } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Panel, Widget } from '@lumino/widgets';\n/**\n * The class name added to inspector panels.\n */\nconst PANEL_CLASS = 'jp-Inspector';\n/**\n * The class name added to inspector content.\n */\nconst CONTENT_CLASS = 'jp-Inspector-content';\n/**\n * The class name added to default inspector content.\n */\nconst DEFAULT_CONTENT_CLASS = 'jp-Inspector-default-content';\n/**\n * A panel which contains a set of inspectors.\n */\nexport class InspectorPanel extends Panel {\n    /**\n     * Construct an inspector.\n     */\n    constructor(options = {}) {\n        super();\n        this._source = null;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        if (options.initialContent instanceof Widget) {\n            this._content = options.initialContent;\n        }\n        else if (typeof options.initialContent === 'string') {\n            this._content = InspectorPanel._generateContentWidget(`<p>${options.initialContent}</p>`);\n        }\n        else {\n            this._content = InspectorPanel._generateContentWidget('<p>' +\n                this._trans.__('Click on a function to see documentation.') +\n                '</p>');\n        }\n        this.addClass(PANEL_CLASS);\n        this.layout.addWidget(this._content);\n    }\n    /**\n     * Print in iframe\n     */\n    [Printing.symbol]() {\n        return () => Printing.printWidget(this);\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Disconnect old signal handler.\n        if (this._source) {\n            this._source.standby = true;\n            this._source.inspected.disconnect(this.onInspectorUpdate, this);\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        // Reject a source that is already disposed.\n        if (source && source.isDisposed) {\n            source = null;\n        }\n        // Update source.\n        this._source = source;\n        // Connect new signal handler.\n        if (this._source) {\n            this._source.standby = false;\n            this._source.inspected.connect(this.onInspectorUpdate, this);\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    /**\n     * Handle inspector update signals.\n     */\n    onInspectorUpdate(sender, args) {\n        const { content } = args;\n        // Update the content of the inspector widget.\n        if (!content || content === this._content) {\n            return;\n        }\n        this._content.dispose();\n        this._content = content;\n        content.addClass(CONTENT_CLASS);\n        this.layout.addWidget(content);\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n    /**\n     * Generate content widget from string\n     */\n    static _generateContentWidget(message) {\n        const widget = new Widget();\n        widget.node.innerHTML = message;\n        widget.addClass(CONTENT_CLASS);\n        widget.addClass(DEFAULT_CONTENT_CLASS);\n        return widget;\n    }\n}\n//# sourceMappingURL=inspector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * The default connector for making inspection requests from the Jupyter API.\n */\nexport class KernelConnector extends DataConnector {\n    /**\n     * Create a new kernel connector for inspection requests.\n     *\n     * @param options - The instantiation options for the kernel connector.\n     */\n    constructor(options) {\n        super();\n        this._sessionContext = options.sessionContext;\n    }\n    /**\n     * Fetch inspection requests.\n     *\n     * @param request - The inspection request text and details.\n     */\n    fetch(request) {\n        var _a;\n        const kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            return Promise.reject(new Error('Inspection fetch requires a kernel.'));\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset,\n            detail_level: 1\n        };\n        return kernel.requestInspect(contents).then(msg => {\n            const response = msg.content;\n            if (response.status !== 'ok' || !response.found) {\n                throw new Error('Inspection fetch failed to return successfully.');\n            }\n            return { data: response.data, metadata: response.metadata };\n        });\n    }\n}\n//# sourceMappingURL=kernelconnector.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The inspector panel token.\n */\nexport const IInspector = new Token('@jupyterlab/inspector:IInspector');\n//# sourceMappingURL=tokens.js.map"],"names":["InspectionHandler","constructor","options","this","_cleared","Signal","_disposed","_editor","_inspected","_isDisposed","_pending","_standby","_lastInspectedReply","_connector","connector","_rendermime","rendermime","_debouncer","Debouncer","onEditorChange","bind","newValue","editor","emit","model","selections","changed","connect","_onChange","value","dispose","isDisposed","customText","text","position","getCursorPosition","offset","Text","getOffsetAt","update","content","pending","fetch","then","reply","data","JSONExt","mimeType","preferredMimeType","widget","createRenderer","MimeModel","renderModel","catch","reason","invoke","CONTENT_CLASS","InspectorPanel","Panel","super","_source","translator","nullTranslator","_trans","load","initialContent","Widget","_content","_generateContentWidget","__","addClass","layout","addWidget","Printing","source","standby","inspected","disconnect","onInspectorUpdate","disposed","onSourceDisposed","sender","args","message","node","innerHTML","KernelConnector","DataConnector","_sessionContext","sessionContext","request","_a","kernel","session","Promise","reject","Error","contents","code","cursor_pos","detail_level","requestInspect","msg","response","status","found","metadata","IInspector","Token"],"sourceRoot":""}