{"version":3,"file":"3597.8725efe8e62c9aea9a34.js","mappings":"2LA+FIA,E,yCArFG,MAAMC,EACTC,cACIC,KAAKC,SAAW,mBAA2B,CACvCC,KAPS,sBAQTC,YAAa,+BACbC,UAAW,WACXC,QAAS,IASjB,UAAUC,GAGN,IAAIC,SAFcP,KAAKQ,UACFC,SACAC,MAAMC,GAChBA,EAAQC,KAAON,IAK1B,OAHKC,IACDA,QAAcP,KAAKa,cAAcP,IAE9BC,EAKX,eACI,IAAIO,EACJ,MAAMC,EAA6D,QAA9CD,EAAK,EAAAE,WAAA,UAAqB,sBAAmC,IAAPF,EAAgBA,EAAK,IAC1FG,cAAoBC,MAAM,EAAAC,OAAA,KAAYJ,EAAa,cAAcK,OAWvE,MAAO,CAAEX,eAVcY,QAAQJ,IAAIA,EAAIK,KAAIC,MAAOC,IAC9C,IAAIV,EACJ,MAAM,GAAEF,GAAOY,EACTC,EAAmD,QAA5CX,QAAYd,KAAKC,SAASyB,QAAQd,UAAyB,IAAPE,EAAgBA,EAAKU,EAAOC,IAC7F,MAAO,IACA5B,EAAQ8B,SAASH,GACpBC,IAAAA,EACAhB,SAAU,QAAYgB,SAYlC,WAAWnB,EAAUmB,SACXzB,KAAKC,SAAS2B,QAAQtB,EAAUmB,GAO1C,oBAAoBnB,GAChB,IAAIQ,EACJ,MAAOe,EAAaC,GAAcxB,EAASyB,MAAM,KACjD,IAAKlC,EAAQmC,YAAYH,GACrB,OAEJ,MAAMI,EAAmB,EAAAjB,WAAA,UAAqB,wBACxCkB,EAAY,EAAAf,OAAA,KAAYc,EAAkBJ,EAAa,UAAWA,EAAa,GAAGC,UAClFK,EAAa,EAAAhB,OAAA,KAAYc,EAAkBJ,EAAa,gBACxDO,cAAsBlB,MAAMgB,IAAYd,OACxCiB,cAA2BnB,MAAMiB,IAAaf,OAC9CK,EAAyD,QAAlDX,QAAYd,KAAKC,SAASyB,QAAQpB,UAA+B,IAAPQ,EAAgBA,EAAK,KACtFL,EAAW,QAAYgB,IAAQ,GACrC,OAAO5B,EAAQ8B,SAAS,CACpBf,GAAIN,EACJmB,IAAAA,EACAW,OAAAA,EACA3B,SAAAA,EACAJ,QAASgC,EAAYhC,SAAW,YAQ5C,SAAWR,GACP,MAAMyC,EAAaC,KAAKC,MAAM,EAAAxB,WAAA,UAAqB,sBAAwB,MAqB3EnB,EAAQmC,YAfR,SAAqBH,GACjB,IAAIY,EACJ,IACIA,EAAYF,KAAKC,MAAM,EAAAxB,WAAA,UAAqB,yBAEhD,MACI,OAAO,EAEX,IAAK,MAAM,KAAEd,KAAUuC,EACnB,GAAIvC,IAAS2B,EACT,OAAO,EAGf,OAAO,GAoBXhC,EAAQ8B,SAZR,SAAkBH,GACd,GAAIc,EAAWd,EAAOZ,IAAK,CAClBY,EAAOY,OAAOM,aAEflB,EAAOY,OAAOM,WAAa,IAE/B,IAAK,MAAOC,EAAMC,KAAgBC,OAAOC,QAAQR,EAAWd,EAAOZ,KAAO,IACtEY,EAAOY,OAAOM,WAAWC,GAAMI,QAAUH,EAGjD,OAAOpB,GAtCf,CAyCG3B,IAAYA,EAAU,KCrIlB,MAAMmD,EAAY,I,SAAIC,OAAM","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../packages/settings/lib/settings.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../../packages/settings/lib/tokens.js"],"sourcesContent":["import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport * as json5 from 'json5';\nimport localforage from 'localforage';\n/**\n * The name of the local storage.\n */\nconst STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A class to handle requests to /api/settings\n */\nexport class Settings {\n    constructor() {\n        this._storage = localforage.createInstance({\n            name: STORAGE_NAME,\n            description: 'Offline Storage for Settings',\n            storeName: 'settings',\n            version: 1\n        });\n    }\n    /**\n     * Get settings by plugin id\n     *\n     * @param pluginId the id of the plugin\n     *\n     */\n    async get(pluginId) {\n        const all = await this.getAll();\n        const settings = all.settings;\n        let found = settings.find((setting) => {\n            return setting.id === pluginId;\n        });\n        if (!found) {\n            found = await this._getFederated(pluginId);\n        }\n        return found;\n    }\n    /**\n     * Get all the settings\n     */\n    async getAll() {\n        var _a;\n        const settingsUrl = (_a = PageConfig.getOption('settingsUrl')) !== null && _a !== void 0 ? _a : '/';\n        const all = (await (await fetch(URLExt.join(settingsUrl, 'all.json'))).json());\n        const settings = await Promise.all(all.map(async (plugin) => {\n            var _a;\n            const { id } = plugin;\n            const raw = (_a = (await this._storage.getItem(id))) !== null && _a !== void 0 ? _a : plugin.raw;\n            return {\n                ...Private.override(plugin),\n                raw,\n                settings: json5.parse(raw)\n            };\n        }));\n        return { settings };\n    }\n    /**\n     * Save settings for a given plugin id\n     *\n     * @param pluginId The id of the plugin\n     * @param raw The raw settings\n     *\n     */\n    async save(pluginId, raw) {\n        await this._storage.setItem(pluginId, raw);\n    }\n    /**\n     * Get the settings for a federated extension\n     *\n     * @param pluginId The id of a plugin\n     */\n    async _getFederated(pluginId) {\n        var _a;\n        const [packageName, schemaName] = pluginId.split(':');\n        if (!Private.isFederated(packageName)) {\n            return;\n        }\n        const labExtensionsUrl = PageConfig.getOption('fullLabextensionsUrl');\n        const schemaUrl = URLExt.join(labExtensionsUrl, packageName, 'schemas', packageName, `${schemaName}.json`);\n        const packageUrl = URLExt.join(labExtensionsUrl, packageName, 'package.json');\n        const schema = await (await fetch(schemaUrl)).json();\n        const packageJson = await (await fetch(packageUrl)).json();\n        const raw = (_a = (await this._storage.getItem(pluginId))) !== null && _a !== void 0 ? _a : '{}';\n        const settings = json5.parse(raw) || {};\n        return Private.override({\n            id: pluginId,\n            raw,\n            schema,\n            settings,\n            version: packageJson.version || '3.0.8'\n        });\n    }\n}\n/**\n * A namespace for private data\n */\nvar Private;\n(function (Private) {\n    const _overrides = JSON.parse(PageConfig.getOption('settingsOverrides') || '{}');\n    /**\n     * Test whether this package is configured in `federated_extensions` in this app\n     *\n     * @param packageName The npm name of a package\n     */\n    function isFederated(packageName) {\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return false;\n        }\n        for (const { name } of federated) {\n            if (name === packageName) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Private.isFederated = isFederated;\n    /**\n     * Override the defaults of the schema with ones from PageConfig\n     *\n     * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227\n     */\n    function override(plugin) {\n        if (_overrides[plugin.id]) {\n            if (!plugin.schema.properties) {\n                // probably malformed, or only provides keyboard shortcuts, etc.\n                plugin.schema.properties = {};\n            }\n            for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {\n                plugin.schema.properties[prop].default = propDefault;\n            }\n        }\n        return plugin;\n    }\n    Private.override = override;\n})(Private || (Private = {}));\n","import { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const ISettings = new Token('@jupyterlite/settings:ISettings');\n"],"names":["Private","Settings","constructor","this","_storage","name","description","storeName","version","pluginId","found","getAll","settings","find","setting","id","_getFederated","_a","settingsUrl","PageConfig","all","fetch","URLExt","json","Promise","map","async","plugin","raw","getItem","override","setItem","packageName","schemaName","split","isFederated","labExtensionsUrl","schemaUrl","packageUrl","schema","packageJson","_overrides","JSON","parse","federated","properties","prop","propDefault","Object","entries","default","ISettings","Token"],"sourceRoot":""}